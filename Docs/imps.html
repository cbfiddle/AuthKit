<html><head><title>Available Authorization Implementations</title></head><body bgcolor="#FFFFFF"><h2>Available Authorization Implementations</h2><blockquote><i>Last revised: 08Aug2003 GLG</i><p><b>Table of Contents</b><ul compact type="disc"><li><a href="#introduction">Introduction</a></li><li><a href="#compatibility">Compatibility</a></li><li><a href="#plain">Plain Implementations</a></li><li><a href="#macosx">Mac OS X Implementations</a></li></ul></blockquote><a name="introduction"></a><h3><font color="#990000">Introduction</font></h3><blockquote>This document describes the concrete Authorization implementationsprovided in the<b><i>Authorization Toolkit for Java.</i></b>If you haven't already read<a href="overview.html">the overview</a>, you should.<p>All necessary JARs and JNI-libraries are provided in ready-to-use form.You don't need to compile anything in order to useany of these concrete Authorization imps on any supported platform.You may recompile if you wish to independently determine the trustworthiness ofthis toolkit, in which case I also recommend a source-code auditand an audit of your development tools.<p>The source for all imps is provided, though some imps may not be recompileableon some platforms unless you obtain additional classes or headers.</blockquote><a name="compatibility"></a><h3><font color="#990000">Compatibility</font></h3><blockquote>The plain implementations work on any platform.They are trivial Java-only implementations, and do not perform any actualsecurity checks, nor do they grant any real privileges.They are mainly useful for testing, or as examples to work from when writing a new implementation.<p>The Mac OS X implementation relies on Authorization Services.It uses native functions available since 10.0, but testing on 10.0 gave<a href="#10.0">mixed results</a>, so deploying on 10.0 is not advised.The minimum Mac OS X version you should deploy AuthKit on is 10.1.The provided code has been tested under J2SE 1.3.1 and 1.4.1_01on Mac OS X 10.1 through 10.2.3.<p>Since the Mac OS X implementation uses Authorization Services,it can interoperate with other programs that use Authorization Services.For example, it can attach to a session using a secret identifierthat is the so-called "external form" of an AuthRef.It can likewise supply that form to a process that needs it, such as ahelper tool written in C, ObjC, C++, etc. that calls Authorization Services itself.<p>All Java source is compatible with JDK 1.1 or higher.</blockquote><a name="plain"></a><h3><font color="#990000">Plain Implementations</font></h3><blockquote>These implementations are platform-neutral plain Java.They provide no real authentication or access controls, nor are childprocesses executed with real elevated privileges.<p><ul type="disc"><li><b>glguerin.authkit.imp.plain.DenyAllAuthorization </b><br>The DenyAllAuthorization class always denies authorization,throwing an UnauthorizedException or IllegalArgumentException as appropriate.It's main use is as a test to see how well programs you write handle denials.It may also serve as a base-class for writing other testing imps that mainly deny.<p></li><li><b>glguerin.authkit.imp.plain.GrantAllAuthorization </b><br>The GrantAllAuthorization class always grants authorization, neverthrowing an UnauthorizedException.It may occasionally throw an IllegalArgumentException.It's main use is as a test to see how well programs you write workwhen all authorization requests are always granted, and no authenticationdialog ever appears.It is also useful when a program is being written in parallel with a newAuthorization implementation, so the program can be run withouthaving the new impl completed.It may also serve as a base-class for writing other testing imps,such as one based on a Dialog or JDialog.<p></li></ul></blockquote><a name="macosx"></a><h3><font color="#990000">Mac OS X Implementations</font></h3><blockquote>These implementations are for Mac OS X.<p>JNI-based implementations have a JNI-based native librarythat must accompany the jar-file.  If the JNI library can't be locatedand loaded, the Java implementation will not work.<ul type="disc"><li><b>glguerin.authkit.imp.macosx.MacOSXAuthorization </b> <br>This implementation uses the native Authorization Services API.It uses native functions available since 10.0, but testing on 10.0 gave<a href="#10.0">mixed results</a>, so deploying on 10.0 is not advised.The minimum Mac OS X version you should deploy AuthKit on is 10.1.The provided code has been tested under J2SE 1.3.1 and 1.4.1_01on Mac OS X 10.1 through 10.2.3.<p>This implementation may work in Cocoa-Java programs.It has not yet been tested there.<p></li></ul><p><a name="10.0"></a><h4>KNOWN PROBLEMS UNDER MAC OS 10.0</h4>All the methods work, so you can use AuthKit on 10.0 if you want to.<p>One notable exception is, well, exceptions.  The result-codes returned from AuthSvcsare not the ones documented for the actual reason.For example, a user-cancellation returns a differentresult-code, so UnauthorizedCancellation isn't thrown when it should be.If you can live with things like that, then AuthKit will work on 10.0.<p>Another thing to consider on 10.0 is the absence of an AuthSvcs policy rule database.There seems to be exactly one policy rule, and it shares credentials and has a 5 minutetimeout.  Since login produces a credential, one questionable consequence of this single ruleis that for 5 minutes after login as an admin user, you don't have to authenticatein order to run a program as root.If the session is detach(true)'ed, and root-execution was overtly authorized,then the shared credential is destroyed.  But that's the only way to actuallycause a subsequent root-execution to authenticate.In my opinion, this is not good.However, if you can live with things like that, then AuthKit will work on 10.0.<p>But then you must also consider how 10.0 mounts non-boot disk volumes.Basically, it does the same thing that Disk Copy does with disk-images:the user who mounted the disk appears to own every file on the disk.For a disk-image this makes sense.For a removable disk, this makes some sense.For partitions mounted at startup, though, it makes no sense at all.However, if you can live with things like that, then AuthKit will work on 10.0.<p>These are just the problems I encountered in my brief testing on 10.0.There may be other problems or peculiarities.If you can live with things like that...</blockquote><hr size="10"  width="95%"><blockquote><a href="http://www.amug.org/~glguerin/index.html">ToGreg's Home Page</a><br><a href="http://www.amug.org/~glguerin/sw/index.html">ToGreg's Software Page</a></blockquote></body></html>