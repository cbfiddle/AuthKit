/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.test;import java.io.*;import glguerin.authkit.*;// --- Revision History ---// 22Nov2002 GLG  create// 17Jun2003 GLG  change to use "attach" property and cover all possible attachment means// 22Jun2003 GLG  add code that prints "java.version" and "java.home" props// 24Jun2003 GLG  add code to resession from stdin// 01Jul2003 GLG  change "pipe from stdin" marker for "attach" value to "@"/**** TestAttach is a command-line test of the three ways an Authorization** can be attached to a session. ** It can call attach() for a secret identifier provided in a file or via stdin.** It can call attachPrivileged() when run as a chiled of execPrivilged().** It can implicitly attach to a new session.**<p>** Since this program is often launched as a privileged process, it always displays** the system properties "java.version" and "java.home", as a diagnostic aid.**<p>** Because of the possible coupling between a privileged Process's stdin and stdout,** this program displays all diagnostics on stderr, never on stdout.** Normally, nothing will be written to stdout.**<p>** All the args are taken to be Privilege names, which are authorize()'d with interaction disallowed,** and failures ignored.  The Privileges then are displayed on stderr,** and optionally appended to files, which are named in "out.N" properties.**<p>** The property "authkit.imp" is ** the fully qualified class name of an Authorization to instantiate and use.**<p>** The optional properties "out.N", where N is a number starting with 1,** are filenames (pathnames) which will have a list of authorized Privileges appended to them.** If the TestAttach process is running with elevated privileges, the owner of any created files** will be root, and any files normally restricted to root will be writable by this program.** Be very careful what you overwrite.**<p>** The optional property "attach" controls how this program attaches to a session:**<ul>**  <li>If the property is missing or empty, then no existing session is**   attached, and a new session is created and used.**   This tests none of the attaching methods.  It's simply the safest path of action.**  </li>**  <li>If the property is ".", then attachPrivileged() is used to attach to the session.**  </li>**  <li>If the property is "@", then stdin is read for the secret identifier,**   and the data read is passed to attach().**   This is a relatively secure approach,**   though due to stdin/stdout coupling, it may or may not be workable in production.**  </li>**  <li>If the property is any other value, then it's treated as a filename whose**   contents is a secret identifier to be used by attach().  **   This is an insecure approach, and is only suitable for testing.**  </li>**</ul>**<p>** Unlike most other classes in this package, diagnostics are emitted on stderr, not stdout.**** @author Gregory Guerin*/public class TestAttach  extends AuthTest{	/**	** Static entry point; can only be used as an application.	*/	public static void 	main( String[] args ) 	{		// All diagnostic messages are sent to stderr.		Authorization auth = makeAuth( null );		explain( "Authorization: " + auth.getClass() );		String attach = System.getProperty( "attach", "" );		int exitCode = new TestAttach().performTest( auth, attach, args );		explain( "TestAttach.main(): done...\n" );		System.exit( exitCode );	}	/**	** Does nothing.  This prevents misuse in AllTests.	*/	public void	testAuth( Authorization auth, String preauthProp, String[] args )	{		explain( "TestAttach: can't be run this way" );	}	/**	** Attach to a session using one of the 3 available means:	**  attach(), attachPrivileged(), or implicitly creating a new session.	** The means of attachment is determined by the 'attach' String, which may be empty.	**<p>	** Once a session is attached or created, the public identifier is emitted on stderr.	** The secret identifier is not directly publicized, but if it came from a file, it's not	** much of a secret.	**<p>	** The args are assumed to be Privilege-names.	** Each is authorize()'d without interaction, ignoring failures.	** The resulting list is then emitted to stderr, and optionally to files named	** by "out.N" properties, where N is a number starting with 1.	*/	private int	performTest( Authorization auth, String attach, String[] args )	{		try		{			// The Authorization should be unattached at this point.			// Decide how to attach a session to it.			if ( attach.equals( "." ) )				auth.attachPrivileged();			else if ( attach.equals( "@" ) )				resession( auth, System.in );			else if ( attach.length() != 0 )				resession( auth, attach );			else				auth.isAvailable( Privilege.EMPTY );  // causes new session creation			// At this point, a session should be attached.			// Authorize all the Privileges named by args, non-interactively but non-fatally.			for ( int i = 0;  i < args.length;  ++i )			{  obtain( auth, args[ i ] );  }			// Spew to stderr...			spewTo( System.err, "-- TestAttach --", auth, args );			// Spew to numbered properties: "out.N"...			for ( int N = 1;  true;  ++N )			{				String filename = System.getProperty( "out." + N, "" );				if ( filename.length() == 0 )					break;				explain( "   writing: " + filename );				spewTo( filename, "-- TestAttach --", auth, args );			}		}		catch ( UnauthorizedException why )		{  explain( why );  return ( 1 );  }		catch ( IllegalArgumentException why )		{  explain( why );  return ( 1 );  }		catch ( IOException why )		{  explain( why );  return ( 1 );  }		return ( 0 );	}	/** Obtain auth: non-interactive and non-fatal. */	private void	obtain( Authorization auth, String name )	{		try		{  auth.authorize( new Privilege( name ), false );  }		catch ( UnauthorizedException why )		{  /* DO NOTHING */ }	}	/** Append information in human-readable form to file. */	protected void	spewTo( String filename, String header, Authorization auth, String[] privNames )	{		PrintStream out = null;		try		{			// Open file for appending.			out = new PrintStream( new FileOutputStream( filename, true ) );			spewTo( out, header, auth, privNames );		}		catch ( IOException why )		{  explain( why );  }		finally		{			if ( out != null )				out.close();		}	}	/**	** Print information in human-readable form to PrintStream.	** The auth's public identifier is displayed, along with the current availability	** of every privName, and its latest-granted date (if any).	*/	protected void	spewTo( PrintStream out, String header, Authorization auth, String[] privNames )	{		out.println( header );		out.println( ".. java.version: " + System.getProperty( "java.version", "???" ) );		out.println( "..... java.home: " + System.getProperty( "java.home", "???" ) );		out.println( ".... Session-ID: " + auth.getPublicIdentifier() );		for ( int i = 0;  i < privNames.length;  ++i )		{			Privilege priv = new Privilege( privNames[ i ] );			out.println( formatPrivilege( "..... Privilege: ", priv, auth ) );		}		out.flush();	}}