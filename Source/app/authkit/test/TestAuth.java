/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.test;import java.io.*;import java.util.*;import glguerin.authkit.*;// --- Revision History ---// 18Nov2002 GLG  create// 20Nov2002 GLG  revise to do multiple exec's using "!" separator// 22Nov2002 GLG  add "externalize" property feature// 22Nov2002 GLG  add code to sleep a little while between exec's, since can't waitFor() Process// 08Jun2003 GLG  cut use of ArrayEnum; use Vector instead, though clunkier// 10Jun2003 GLG  revise to use Digester// 10Jun2003 GLG  add "!name" support to revoke previously granted Privileges// 11Jun2003 GLG  add "#" support to release() session// 12Jun2003 GLG  switch to ":" separator between exec's, avoiding shell's history mechanism// 12Jun2003 GLG  add a bunch of builtins; change class-name to TestAuth// 13Jun2003 GLG  add builtins: put, get// 16Jun2003 GLG  add builtin: zzz// 17Jun2003 GLG  revise how privileged Process is waited for// 17Jun2003 GLG  add "between" property so BETWEEN is configurable// 17Jun2003 GLG  change doGet() so "." uses attachPrivileged()// 20Jun2003 GLG  add "JAVA" builtin; expand doc-comments// 22Jun2003 GLG  add "ver" builtin// 23Jun2003 GLG  add per-command piping of secret using "@" prefix/**** TestAuth is the Swiss Army Knife test for Authorization methods.** It can call every method of Authorization in one way or another.** It does this by acting as a simple command interpreter over its command-line args.** Some of its commands are "builtins" that call the Authorization methods.** Everything else is an external command, which is run with elevated privileges** using the execPrivileged() method.**<p>** The command-line args form an interpretable sequence of strings consisting of:**<ol type="1">**  <li>builtin commands, with args</li>**  <li>external commands, with args</li>**  <li>separators between groupings of command+args</li>**</ol>**<p>** The command parser is very simple, and works with the individual Strings of** the String[] received by main().  Those Strings are not subdivided or otherwise parsed or manipulated.** The interpreter simply breaks the sequence into groups, examines the first String** of the group, and acts accordingly.** For example, the grouping separator is ":", but it's only recognized in isolation.** The interpreter will not recognize embedded :'s, nor will it subdivide commands or args at :'s.**<p>** A command grouping is separated from a subsequent grouping by** a single isolated ":".  Within a grouping, the first String is the command, and all other** Strings are args for that command.  A grouping may be empty, which is quietly ignored.**<p>** Builtins were named to minimize collisions with external commands on Mac OS X.** The builtin commands and their args are:**<dl>**  <dt><b><tt>see [privilege-name ...]</tt></b>**  </dt><dd>**  Display the current availability of each privilege-name, by calling isAvailable().**  If no privilege-names are given, then list identity, latest date granted, and**  current availability of the getPastGrantedPrivileges() enumeration.**  </dd>****  <dt><b><tt>pre privilege-name [...]</tt></b>**  </dt><dd>**  Call preauthorize() for the named privilege(s).  Interaction is always allowed.**  To preauthorize the root-execution privilege, use a name of "system.privilege.admin" on Mac OS X.**  </dd>****  <dt><b><tt>au+ privilege-name [...]</tt></b>**  </dt><dd>**  Call authorize() for the named privilege(s), with interaction allowed.**  </dd>****  <dt><b><tt>au- privilege-name [...]</tt></b>**  </dt><dd>**  Call authorize() for the named privilege(s), with interaction disallowed.**  </dd>****  <dt><b><tt>put [pathname ...]</tt></b>**  </dt><dd>**  Write the secret identifier in binary to each given pathname, overwriting any file of that name.**  If no pathnames are given, the secret identifier is dumped to stdout in hex.**  <br><b>THIS APPROACH IS INSECURE, AND IS ONLY SUITABLE FOR TESTING.</b>**  </dd>****  <dt><b><tt>get [pathname]</tt></b>**  </dt><dd>**  If pathname is ".", call attachPrivileged() on a new Authorization, using it if successful.**  If pathname is anything other than ".", read the secret identifier from the file,**  call attach() on a new Authorization, and use it if successful.**  The secret identifier in a file must refer to a still-active session, or it will fail.**  The "." notation will only work if TestAuth is running in a JVM that was executed**  as a child of execPrivileged().  Also see the TestAttach class.**  </dd>****  <dt><b><tt>#</tt></b>**  </dt><dd>**  Call release() on the current Authorization.**  </dd>****  <dt><b><tt>##</tt></b>**  </dt><dd>**  Call detach( true ) on the current Authorization.**  </dd>****  <dt><b><tt>ver</tt></b>**  </dt><dd>**  Print the values of the "java.version" and "java.home" system properties, as a diagnostic aid..**  This calls no Authorization method.**  </dd>****  <dt><b><tt>zzz [seconds]</tt></b>**  </dt><dd>**  Sleep for the given integer number of seconds, or for 3 secs if no value given.**  This calls no Authorization method.  It only uses Java code, and does not execute an external command.**  </dd>**</dl>**<p>** Any command not recognized as a builtin is interpreted as an external command,** and will be executed using execPrivileged().  Some pre-processing may occur first:**<dl>**  <dt><b><tt>JAVA ...</tt></b>**  </dt><dd>**  The all-upper-case "JAVA" command is a quasi-builtin, a little like a shell command-alias.**  It eventually executes an external command, but some substitution happens first.**  It takes the "java.home" property, appends "/bin/java" to it, and then**  executes that as an external command using execPrivileged().**  <p>**  The reason for doing this is that "java.home" will reflect the JVM currently running,**  which may be 1.3.1 or 1.4.1 on Mac OS X, and execute that same JVM in another process.**  If you just entered the command "/usr/bin/java", it won't necessarily be the current JVM.**  <p>**  You can customize which command in "java.home" is executed by defining it as a relative pathname**  in the "auth.bin.java" property.  Be sure to use a file-separator appropriate to your platform.**  The value should always be a partial pathname relative to the location given by "java.home".**  </dd>****  <dt><b><tt>@ <i>command</i> [...]</tt></b>**  </dt><dd>**  When "@" appears as a separated token before an external command,**  then that command will have the secret identifier piped to it on its stdin stream.**  The "@" must be separated from the following command by white-space.**  Any external command can be run, including the <b>JAVA</b> quasi-builtin.**  Only commands that read their standard input**  will be useful.  For example, the 'echo' command will be useless at reading the secret.**  </dd>**</dl>**<p>** All external commands are executed using execPrivileged(), so they all run with elevated privileges.** This is unwise as a general approach, but is acceptable for a test.**<p>** If authorization is needed before running an external command, it is obtained interactively if necessary.** Failure to authorize or authenticate will fail to run the external command.**<p>** On Mac OS X, all commands executed by execPrivileged() must be absolute pathnames.** If you don't know the absolute pathname of a command, use the 'which' command in your** shell to tell you the pathname of a particular command.  For example, 'which java' or 'which id'.**<p>** The external command's stdout is piped to the System.out stream,** and the bytes are counted and CRC'ed for comparison purposes.** On Mac OS X, the stderr is simply shared with the privileged process.**<p>** If the Authorization's privileged Process implements waitFor(), the external command is waited for.** Otherwise a 3-second delay occurs, then the interpreter resumes parsing and executing commands.** Since MacOSXAuthorization's privileged Process doesn't provide waitFor(), long-running** external commands may need a subsequent 'zzz' builtin command.**<p>** Before each command is executed, whether builtin or external, the Authorization's current public identifier** is displayed on stdout.  This is done to help track when sessions are created, attached, and detached.** It's also useful to compare to public identifiers displayed by other processes that attach** to the same session.  The identifiers should be identical, even though from different processes.**<p>** Several system properties affect the TestAuth command interpreter:** <dl>** <dt><b><tt>"authkit.imp"</tt></b>** </dt><dd>** This property's value is** the fully qualified class name of an Authorization to instantiate and use.** See method main().** </dd>** ** <dt><b><tt>"between"</tt></b>** </dt><dd>** This optional property defines an override for the ":" string separating command groupings.** The main use for this property is so you can execute a privileged version of this class in another process,** and change the separator.  If you couldn't change the separator, you couldn't distinguish its** commands from those of its parent.  That's because the TestAuth interpreter doesn't do escaping.** Usually, you don't have to set "between" or change it in any way.** </dd>** ** <dt><b><tt>"auth.bin.java"</tt></b>** </dt><dd>** This optional property defines an override for the "bin/java" command** assembled by the quasi-builtin <b>JAVA</b> command.** The main use for this property is when the external command isn't "bin/java",** such as on Windows.** Usually, you don't have to set "auth.bin.java" or change it in any way.** See method doExec().** </dd>** ** </dl>**** @author Gregory Guerin*/public class TestAuth  extends AuthTest{	// For convenience in formatting, all true builtins are the same length,	// except for the release() and detach() ones.	private static final String		BETWEEN = ":",			// isolated separator between command+args groups		AVAIL = "see",			// builtin that lists availability of named Privileges, or past granted		PREAUTH = "pre",		// builtin that preauthorizes the named privileges		AUTH_W = "au+",		// builtin that authorizes the named privileges, with interaction		AUTH_WO = "au-",		// builtin that authorizes the named privileges, without interaction		PUT = "put",				// builtin that writes secret identifier's binary to file, or hex to stdout		GET = "get",				// builtin that reads secret identifier from file (prior one is detach(true)'ed)		RELEASE = "#",			// builtin that causes release()		DESTROY = "##",			// builtin that causes detach(true)		VERSION = "ver",		// builtin that prints "java.home" and "java.version"		SNOOZE = "zzz";			// builtin that sleeps for N seconds	/** These are handled entirely in doExec(). */	private static final String		AT = "@",					// prefix that exec's command, piping secret identifier to it		JAVA = "JAVA";			// quasi-builtin that exec's command at {java.home}/bin/java	/**	** Static entry point, when used as an application.	*/	public static void 	main( String[] args ) 	{		tell( "TestAuth.main(): starting..." );		Authorization auth = makeAuth( null );		tell( "Authorization: " + auth.getClass() );		new TestAuth().testAuth( auth, "dont-care", args );		tell( "TestAuth.main(): done...\n" );	}	private final String myBetween;	/** Create with default separator defined by "between" property, or ":". */	public	TestAuth()	{		myBetween = System.getProperty( "between", BETWEEN );	}	/**	** Do the test over all the args.	** In this test, the args represent a series of command+parameters groupings.	** As a result, we DO NOT want to iterate using AuthTest.testAuth(), hence this override.	**<p>	** The groupings contain both external commands, which must have absolute pathnames,	** and builtin commands, which are performed by methods of this class.	** All external commands are executed using Authorization.execPrivileged().	*/	public void	testAuth( Authorization auth, String dontCare, String[] args )	{		try		{			// Before anything else happens, be sure auth is attached to a session.			auth.isAvailable( Privilege.EMPTY );			// Process all the args.			decodeActions( auth, args );		}		catch ( UnauthorizedException why )		{  explain( why );  }		catch ( IllegalArgumentException why )		{  explain( why );  }		tell( "" );	}	/**	** Do the actual parsing and execPriv() testing.	** The args may contain multiple commands, separated by myBetween's.	** Also, builtins represented by RELEASE, DESTROY, etc. are recognized,	** and cause a local action on the Authorization, rather than exec'ing anything.	*/	private void	decodeActions( Authorization auth, String[] argArray )	{		// Use Vectors as an easy way to group the args given in argArray.		// It can be done without Vectors, but it's simpler to do the grouping this way.		Enumeration argsEnum = asVector( argArray ).elements();		Vector group = new Vector( argArray.length );		while ( true )		{			// Discard anything previously in group, then collect			// a group until next myBetween, or end of args.			for ( group.removeAllElements();  argsEnum.hasMoreElements();  )			{				String item = argsEnum.nextElement().toString();				if ( item.equals( myBetween ) )					break;				group.addElement( item );			}			// At this point, 'group' has a group of arg-Strings or is empty.			// If argsEnum has more args, continue; otherwise break.			int groupLen = group.size();			if ( groupLen == 0 )			{				if ( argsEnum.hasMoreElements() )					continue;				else					break;			}			String[] progArray = new String[ groupLen ];			group.copyInto( progArray );			try			{				// Get command and decide what to do with it.				String cmd = progArray[ 0 ];				tell( "-----with: " + getWhich( auth ) + " (" + cmd + ")" );				if ( cmd.equals( RELEASE ) )				{					// The Auth is release()'d.  As later needed, a new session is established.					tell( "  Release: " + getWhich( auth ) );					auth.release();				}				else if ( cmd.equals( DESTROY ) )				{					// The Auth is detach(true)'ed.  As later needed, a new session is established.					tell( "  Destroy: " + getWhich( auth ) );					auth.detach( true );				}				else if ( cmd.equals( AVAIL ) )				{					// -- List availability of each name as Privilege, or past granted					doAvail( auth, progArray, 1 );				}				else if ( cmd.equals( PREAUTH ) )				{					// -- Preauth remainder of names as Privileges					doPreauth( auth, progArray, 1 );				}				else if ( cmd.equals( AUTH_W ) )				{					// -- Authorize remainder of names as Privileges					doAuth( auth, progArray, 1, true );				}				else if ( cmd.equals( AUTH_WO ) )				{					// -- Authorize remainder of names as Privileges					doAuth( auth, progArray, 1, false);				}				else if ( cmd.equals( PUT ) )				{					// -- Write secret identifier to file, or dump as hex to System.out					doPut( auth, progArray, 1 );				}				else if ( cmd.equals( VERSION ) )				{					// -- print properties					doVersion( auth, progArray, 1 );				}				else if ( cmd.equals( SNOOZE ) )				{					// -- sleep for N secs, or for 3 if no other args					doSnooze( auth, progArray, 1 );				}				else if ( cmd.equals( GET ) )				{					// -- Read secret identifier from file, if any.					// If result is different Authorization reference, detach(true) the old one.					// If they both refer to the same session, the detach() will not change					// any privileges or credentials in the session, since the session will be					// connected to one Authorization or the other the entire time.					Authorization got = doGet( auth, progArray, 1 );					if ( got != auth )					{						tell( "      got: " + getWhich( got ) );						tell( "   detach: " + getWhich( auth ) );						auth.detach( true );						auth = got;					}				}				else				{					// -- Execute as external command					doExec( auth, progArray );				}			}			catch ( UnauthorizedException why )			{  explain( why );  }			catch ( IllegalArgumentException why )			{  explain( why );  }			catch ( Throwable why )			{  explain( why );  }		}	}	private Vector	asVector( Object[] array )	{		Vector vector = new Vector( array.length );		for ( int i = 0;  i < array.length;  ++i )		{  vector.addElement( array[ i ] );  }		return ( vector );	}	private void	doAvail( Authorization auth, String[] progArray, int index )	{		if ( index < progArray.length )		{			while ( index < progArray.length )			{				Privilege priv = new Privilege( progArray[ index++ ] );				tellPrivilege(  "Privilege: ", priv, auth );			}		}		else		{			tell( " Past Granted... " );			tellGranted( "Privilege: ", auth );		}	}	private void	doPreauth( Authorization auth, String[] progArray, int index )	{		while ( index < progArray.length )		{			Privilege priv = new Privilege( progArray[ index++ ] );			tell( "Privilege: " + priv );			auth.preauthorize( priv );			// Getting here, we are preauthorized.			tellPrivilege( "  preauth: ", priv, auth );		}	}	private void	doAuth( Authorization auth, String[] progArray, int index, boolean withInteraction )	{		while ( index < progArray.length )		{			Privilege priv = new Privilege( progArray[ index++ ] );			tell( "Privilege: " + priv );			auth.authorize( priv, withInteraction );			// Getting here, we are authorized.			tellPrivilege( "     auth: ", priv, auth );		}	}	private void	doPut( Authorization auth, String[] progArray, int index )	  throws IOException	{		// Strings in progArray are filenames.		if ( index < progArray.length )		{			while ( index < progArray.length )			{  writeSecret( auth, progArray[ index++ ] );  }		}		else		{			// HANDLES SECRET INSECURELY.  Should use try/finally to erase it.			byte[] secret = auth.getSecretIdentifier();			putHexTo( System.out, "## Secret identifier:", "  ", secret, -1 );		}	}	/**	** <b>THIS METHOD IS FOR TESTING ONLY.  IT IS NOT SECURE, BY DESIGN.</b>	** Any other process can read the file containing the session's secret identifier.	** <b>DO NOT USE THIS APPROACH IN PRODUCTION CODE.</b>	*/	private void	writeSecret( Authorization auth, String filename )	  throws IOException	{		if ( filename == null  ||  filename.length() == 0 )			return;		byte[] secret = null;		OutputStream out = null;		try		{			out = new FileOutputStream( filename );			secret = auth.getSecretIdentifier();			out.write( secret );			tell( "    wrote: " + filename );		}		finally		{			// If this was secure, I'd erase secret here.			// There's no point in doing so, though, since file contains not-so-secret secret.			if ( out != null )			{  out.close();  }		}	}	/**	** Returns original Auth, or a new Auth of same Class	** attach()'ed to secret identifier loaded from a named file.	** Neither the original Authorization nor the result is detach()'ed.	*/	private Authorization	doGet( Authorization auth, String[] progArray, int index )	  throws IllegalAccessException, InstantiationException	{		Authorization result = auth;		// The progArray holds filenames. Only use first filename, if any given.		if ( index < progArray.length )		{			// This blindly assumes the concrete Class has a no-args constructor.			// It should, but it would be safer to check first.			result = (Authorization) (auth.getClass().newInstance());			// If name is ".", use attachPrivileged() instead of resession()'ing via a file.			String name = progArray[ index ];			// The new Auth in 'result' should be unattached at this point.			// Decide how to attach a session to it.			if ( name.equals( "." ) )				result.attachPrivileged();			else				resession( result, name );		}		// At this point, result will be original Auth, or a just-attach()'ed new Auth.		return ( result );	}	/**	** Print property values.	*/	private void	doVersion( Authorization auth, String[] progArray, int index )	  throws IllegalAccessException, InstantiationException	{		tell( " java.version: " + System.getProperty( "java.version", "???" ) );		tell( "    java.home: " + System.getProperty( "java.home", "???" ) );	}	/** Doesn't use Auth, but keep it for a foolish consistency. */	private void	doSnooze( Authorization auth, String[] progArray, int index )	  throws IOException	{		// Default if no args		int secs = 3;		// Strings in progArray are numbers of seconds.		// Only use first one, if any.		if ( index < progArray.length )		{			try			{  secs = Integer.parseInt( progArray[ index ] );  }			catch ( NumberFormatException useDecimalNumbersYouIdiot )			{  secs = 3;  }			// This prevents hangs for "0" or "-23".			if ( secs <= 0 )				secs = 3;		}		tell( " sleeping: " + secs );		dawdle( secs );	}	private void	dawdle( int secs )	{		try		{  Thread.sleep( secs * 1000L );  }		catch ( InterruptedException why )		{  explain( why );  }	}	/**	** Attach a Digester to child's stdout stream, pumping it to my System.out.	**<p>	** Until the privileged Process implements waitFor() correctly,	** we just sleep for a customary interval of time (3 secs).	*/	private void	doExec( Authorization auth, String[] progArray )	{		boolean pipeSecret = false;		// First, check for "@" prefix, meaning that secret identifier		// will be sent through pipe, if possible.		if ( progArray[ 0 ].equals( AT ) )		{			String[] smaller = new String[ progArray.length - 1 ];			System.arraycopy( progArray, 1, smaller, 0, smaller.length );			progArray = smaller;			pipeSecret = true;		}		// Next, check for match to "JAVA" and substitute expansion of		// "java.home" property with "/bin/java" appended in File-friendly way.		if ( progArray[ 0 ].equals( JAVA ) )		{			// Always append one separator, since java.home may not end in "/".			// This ensures that "auth.bin.java" will always be interpreted relative to java.home.			StringBuffer build = new StringBuffer( System.getProperty( "java.home", "" ) );			build.append( File.separator );			// If "auth.bin.java" property is present, append it; otherwise assemble manually.			String binJava = System.getProperty( "auth.bin.java", "" );			if ( binJava.length() != 0 )				build.append( binJava );			else				build.append( "bin" ).append( File.separator ).append( "java" );			progArray[ 0 ] = build.toString();		}		tell( "Executing: " + progArray[ 0 ] );		// Without a prior unexpired preauth or auth, execPrivileged()		// will do what it needs to authenticate and obtain authorization.		Process child = auth.execPrivileged( progArray );		tell( "  process: " + child );		tell( "    class: " + child.getClass().getName() );		// If possible, attach a Digester to child's stdout stream, .		// An IllegalArgumentException from Process means "unimplemented", and is non-fatal.		if ( auth.isCapable( auth.HAS_PROCESS_INPUTSTREAM ) )		{			try			{				// Transfer child's stdout stream, summarize on System.out using MD5 digest, if possible.				Digester digester = new Digester( child.getInputStream(), System.out, "MD5" );				Thread deamon = digester.makeDaemon( null, "Digester-daemon" );				deamon.setPriority( Thread.MAX_PRIORITY );  // eat greedily	//			deamon.setDaemon( false );  // see how this affects exit()				deamon.start();			}			catch ( IllegalArgumentException why )			{  /* IGNORED */  }  // will have been thrown from getInputStream(), meaning nothing is digestible.		}		// Only pipe secret identifier to child if pipeSecret is true,		// and if child Process supports it.		if ( pipeSecret  &&  auth.isCapable( auth.HAS_PROCESS_OUTPUTSTREAM ) )		{			byte[] secret = null;			try			{				OutputStream out = child.getOutputStream();  // child's stdin stream				secret = auth.getSecretIdentifier();				out.write( secret );				out.flush();				out.close();				tell( "    wrote: " + secret.length + " secret bytes to child" );			}			catch ( Throwable why )			{  explain( why );  }			finally			{				// Ensure any secret bytes are erased.				if ( secret != null )				{					for ( int i = 0;  i < secret.length;  ++i )					{  secret[ i ] = 0;  }					secret = null;				}			}		}		// Check capabilities to see if Process.waitFor() is available.		// If it's not, then just dawdle awhile.		if ( auth.isCapable( auth.HAS_PROCESS_WAITFOR ) )		{			int exited;			try			{  exited = child.waitFor();  }			catch ( InterruptedException why )			{  throw new IllegalArgumentException( "Unexpectedly interrupted" );  }			tell( "   exited: " + exited );		}		else		{			tell( "  sleeping a few seconds..." );			dawdle( 3 );		}	}}