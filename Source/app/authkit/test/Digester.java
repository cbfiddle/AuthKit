/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.test;import java.io.*;import java.util.zip.*;import app.hex.Hex;import glguerin.util.Streamer;// --- Revision History ---// 26Nov2002 GLG  create// 10Jun2003 GLG  refactor to use glguerin.util.Streamer// 16Jun2003 GLG  rework to use CRC32 instead of a MessageDigest/**** A Digester uses a Thread to read an InputStream until EOF,** optionally calculating a message-digest or checksum on it.  ** This is useful when dealing with Processes that produce data on stdout,** and we want to easily tell if different Processes produce the same data,** without doing a byte-by-byte comparison.**<p>** Without a digest or checksum, the data simply flows through and is counted.** With a digest or checksum, we can see whether the data was the same as** another by visually comparing the displayed digest or checksum values.**<p>** A CRC (e.g. java.util.zip.CRC32) is smaller than a MessageDigest,** so is more easily compared by visual inspection,** but isn't as unique.**<p>** On EOF, the Thread terminates, optionally displaying its results to a PrintStream.** This will be either a byte-count, or a byte-count and a checksum or digest.**** @author Gregory Guerin*/public class Digester  extends Streamer{	protected CRC32 checker;	protected PrintStream prout;	/**	** Transfer the InputStream, displaying data and results on a PrintStream,	** and running the data through a MessageDigest of the given algorithm-name.	** If the PrintStream is null, no results are emitted.	** If the digestName is null, no digest is produced.	*/	public	Digester( InputStream toConsume, PrintStream toExplain, String digestName )	{		// Superclass constructor assigns values to instance variables.		// InputStream is unassigned, and is not closed on EOF.		// OutputStream is toExplain, not closed on EOF, but flushed on each write.		super( new byte[ 8 * 1024 ],  null, false,  toExplain, false, true );		in = getInput( toConsume, digestName );		prout = toExplain;		// may be null	}	/** Returns the original stream, or a checked or digested InputStream fed from it. */	protected InputStream	getInput( InputStream stream, String digestName )	{		if ( digestName != null )		{			checker = new CRC32();			stream = new CheckedInputStream( stream, checker );		}		return ( stream );	}	/**	** Pump bytes from the InputStream to the optional OutputStream (PrintStream).	** May also print a summary and digest in text form to PrintStream.	*/	public void	run()	{		long count = 0;		try		{			count = pump();		}		catch ( Throwable why )		{			if ( prout != null )				why.printStackTrace( prout );		}		finally		{			if ( prout != null )			{				prout.println( "....count: " + count );				if ( checker != null )				{					prout.print( "....check: 0x" );					prout.print( Hex.getHex( checker.getValue(), 8 ) );					prout.println( " -- CRC32" );				}				// Flush, but don't close.				prout.flush();			}		}	}}