/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.test;import java.io.*;import java.util.*;import app.hex.*;import glguerin.authkit.*;// --- Revision History ---// 29Oct2002 GLG  create stub// 09Nov2002 GLG  rework into more substantial base class// 22Nov2002 GLG  rework hex-dump methods// 12Jun2003 GLG  add tellWhich() and getWhich()// 14Jun2003 GLG  change getWhich() to use getPublicIdentifier()// 16Jun2003 GLG  move resession() here// 17Jun2003 GLG  refactor, adding formatPrivilege()// 24Jun2003 GLG  refactor resession() into two variants/**** AuthTest is a superclass for testing AuthKit code.** Each subclass tests some code by providing a testAuthOne() override,** or perhaps an override of testAuth().**<p>** A subclass may provide none of the usual test methods, instead providing** only a main() method for command-line execution.  In those case, the** utilitarian methods of this class are available.**<p>** The property "authkit.imp" is usually used as** the fully qualified class name of an Authorization to instantiate and use.**** @author Gregory Guerin*/abstract public class AuthTest{//	protected static boolean allowInteraction;	/**	** Typical static entry point, when used as an application.	*//*	public static void 	main( String[] args ) 	{		tell( "AuthTest.main(): starting..." );		Authorization auth = makeAuth( null );		tell( "Authorization: " + auth.getClass() );		new AuthTest().testAuth( auth, args );		tell( "AuthTest.main(): done...\n" );	}*/	/**	** Do the test over all the args.	** First, read the "interact" property and pass its state to testAuthOne().	** The default flag state is true.	*/	public void	testAuth( Authorization auth, String interactProp, String[] args )	{		boolean interact = "true".equalsIgnoreCase( System.getProperty( interactProp, "true" ) );		for ( int i = 0;  i < args.length; ++i )		{			try			{				testAuthOne( auth, interact, args[ i ] );  			}			catch ( UnauthorizedException why )			{  explain( why );  }			catch ( IllegalArgumentException why )			{  explain( why );  }		}		tell( "" );		tellGranted( "..granted: ", auth );		tell( "" );	}	/** Do the test on one arg. */	public void	testAuthOne( Authorization auth, boolean interact, String arg )	{		return;	}	/**	** The returned Authorization is unattached to any underlying session.	*/	public static Authorization	makeAuth( String propName )	{		if ( propName == null  ||  propName.length() == 0 )			propName = "authkit.imp" ;		// Look for that system property specifying a class name.		// Absent such a property, return a DenyAllAuthorization as the safest thing.		String className = System.getProperty( propName );		if ( className == null  ||  className.length() == 0 )			className = "glguerin.authkit.imp.plain.DenyAllAuthorization";		try		{			// If any of this throws any kind of exception, catch it and fail instead.			return ( (Authorization) Class.forName( className ).newInstance() );		}		catch ( ThreadDeath mustRethrow )		{  throw mustRethrow;  }		catch ( Throwable anythingElse )		{  explain( anythingElse );  }		// Log failure and return null, which will cause caller to fail.		return ( null );	}	/**	** Show the enumerated past granted privileges.	*/	protected void	tellGranted( String prefix, Authorization auth )	{		Enumeration past = auth.getPastGrantedPrivileges();		while ( past.hasMoreElements() )		{  tellPrivilege( prefix, (Privilege) past.nextElement(), auth );  }	}	/**	** Show the past and current state of a single Privilege.	** If not previously granted, then no past-granted date appears.	*/	protected void	tellPrivilege( String prefix, Privilege priv, Authorization auth )	{  tell( formatPrivilege( prefix, priv, auth ) );  }	/**	** Assemble the past and current state of a single Privilege.	** If not previously granted, then no past-granted date appears.	*/	protected String	formatPrivilege( String prefix, Privilege priv, Authorization auth )	{		StringBuffer build = new StringBuffer( prefix ).append( priv );		if ( auth != null )		{			// Show latest grant timestamp, i.e. most recent time when authorize()'d.			Date when = auth.getPastGrantedDate( priv, auth.WHEN_LATEST );			if ( when != null )				build.append( " at " ).append( when );			build.append( " -- " ).append( auth.isAvailable( priv ) );		}		return ( build.toString() );	}	/**	** Call getWhich() and print with prefix.	*/	protected void	tellWhich( Authorization auth )	{  tell( "..Auth-ID: " + getWhich( auth ) );  }	/**	** If unattached to a session, create a new session,	** then return a String uniquely identifying that session: i.e. return getPublicIdentifier().	*/	protected String	getWhich( Authorization auth )	{		String which = auth.getPublicIdentifier();		if ( which.length() != 0 )			return ( which );		auth.isAvailable( Privilege.EMPTY );		return ( auth.getPublicIdentifier() );	}	/**	** Attach the Authorization to the secret identifier loaded from the given filename.	** The Authorization must be in a released state.	**<p>	** <b>THIS IS INSECURE.  DO NOT USE IN PRODUCTION CODE.</b>	*/	protected void	resession( Authorization auth, String filename )	{		InputStream in = null;		try		{			in = new FileInputStream( filename );			resession( auth, in );		}		catch ( IOException why )		{  explain( why );  }		finally		{			if ( in != null )			{				try				{  in.close();  }				catch ( IOException why )				{  explain( why );  }			}		}	}	/**	** Attach the Authorization to the secret identifier read from the given InputStream.	** The stream is not closed.	** The Authorization must be in a released state.	** A try/finally block ensures the secret buffer is erased in all cases.	*/	protected void	resession( Authorization auth, InputStream in )	  throws IOException	{		// Use an exact-size buffer to hold the secret data.		byte[] secret = new byte[ auth.getSecretLength() ];		try		{			// Naively assume a single read() gets all available data into buffer.			// DO NOT DO THIS IN PRODUCTION CODE.			int got = in.read( secret );			if ( got != secret.length )				throw new IOException( "Wrong number of bytes: " + got + " of " + secret.length );			auth.attach( secret );		}		finally		{			for ( int i = 0;  i < secret.length;  ++i )			{  secret[ i ] = 0;  }		}	}	/** Append all bytes, in hex, to file. */	protected void	putHexTo( String filename, byte[] bytes )	{  putHexTo( filename, "# -- ", "  ", bytes, bytes.length );  }	/** Append bytes, in hex, to file. */	protected void	putHexTo( String filename, String header, String prefix, byte[] bytes, int count )	{		try		{			PrintStream out = new PrintStream( new FileOutputStream( filename, true ) );			putHexTo( out, header, prefix, bytes, count );			out.close();		}		catch ( IOException why )		{  explain( why );  }	}	/** Print bytes in hex to PrintStream. */	protected void	putHexTo( PrintStream out, String header, String prefix, byte[] bytes, int count )	{		if ( header != null )			out.println( header );			if ( count < 0  ||  count > bytes.length )			count = bytes.length;		int hop = 16;		for ( int line = hop, offset = 0;  count > 0;  offset += hop, count -= hop )		{			if ( count < hop )  line = count;			hexLine( out, prefix, bytes, offset, line );		}	}	/**	** Print the bytes in hex as one line of text,	** preceded by a given non-null prefix, and	** followed by a call to PrintStream.println().	*/	protected void 	hexLine( PrintStream out, String prefix, byte[] bytes, int offset, int count )	{		StringBuffer hexBuf = new StringBuffer( 3 );		out.print( prefix );		for ( int gap = 0;  count > 0;  --count, ++offset )		{			hexBuf.setLength( 0 );			Hex.appendHex( hexBuf, 0xFF & bytes[ offset ], 2 );			hexBuf.reverse();			hexBuf.append( ' ' );			if ( (++gap & 0x03) == 0 )  { hexBuf.append( ' ' ); }			out.print( hexBuf.toString() );		}		out.println();	}	/** Emit line of text on stdout. */	public static void	tell( String toTell )	{  System.out.println( toTell );  }	/** Emit line of text on stderr. */	public static void	explain( String text )	{		System.out.flush();		System.err.println( text );	}	/** Emit stack trace on stderr. */	public static void	explain( Throwable toExplain )	{  toExplain.printStackTrace( System.err );  }}