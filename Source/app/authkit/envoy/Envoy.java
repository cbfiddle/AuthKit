/*** Copyright 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.envoy;import java.io.*;import java.util.*;import glguerin.authkit.*;import glguerin.util.*;// --- Revision History ---// 17Jul2003 GLG  create// 18Jul2003 GLG  add getter methods and template methods// 26Jul2003 GLG  revise protocol behavior// 29Jul2003 GLG  doc-comments// 06Aug2003 GLG  call explain() in taskPerform() for any Throwable caught/**** Envoy performs Tasks in a presumably privileged process, reporting on their success.**<p>** The Envoy.main() method is the typical entry-point of a privileged process,** executed via Authorization.execPrivileged().** As a result, its stdin and stdout (System.in and System.out) are presumed** to be connected to a pipe going back to the parent process.** The pipe's streams may be coupled together, so closing one may close both.** This constrains how the Envoy can communicate results back to its parent.** The Envoy is expected to return Task outcomes and data on its stdout, including its own** termination status, since the privileged Process in the parent may not provide waitFor()** or exitValue().**<p>** An Envoy's stderr stream is typically inherited from the parent process, and usually** writes to the system console (or its log-file) in a double-clicked app.** It writes to stderr when invoked at** the command-line or in other-than-double-clicked launches.** It may or may not be used by the Envoy protocol.** By default, it is not.**<p>** The simplest communication protocol for an Envoy is to only return its own** "exit status" on stdout, and to discard all output produced by Tasks or external commands.** The provided protocol can do more than that, but it's still very simple,** if not simple-minded.****<h3>Basic Envoy Communication Protocol</h3>**** The current Envoy communication protocol is brutally simple.** It uses the default System I/O streams for its own communications,** and sets different streams into System.in, .out, and .err for use by Tasks.** It uses the I/O streams as follows:**<dl>**  <dt>System.in (stdin)</dt>**  <dd>Not used.**    For Tasks, replaced with an immediate-EOF stream using System.setIn().**  </dd>****  <dt>System.out (stdout)</dt>**  <dd>**    Send progress messages and result text back to client (the parent process).**    For Tasks, replaced by either an actual stream or a data sink stream,**    depending on whether the Task produces output or not.**    <b>No Task should close System.out.</b>**  </dd>****  <dt>System.err (stderr)</dt>**  <dd>**    Available for diagnostics, such as stack-traces, etc.**    This stream is not currently used by the Envoy protocol, though**    the default Envoy class will print failure stack-traces on it.**    Tasks may freely print() or println() or printStackTrace() to this stream.**    <b>No Task should close System.err.</b>**  </dd>**</dl>** If a Task produces output that is sent back to the parent process,** and the Task closes System.out, it will cause a protocol failure.** So don't do that.** In the future, a safer stream may be used that doesn't actually close the stream** on close(), but only flushes it.**<p>** As each Task is undertaken, the Envoy sends a task-begin message.** As each Task is completed, the Envoy sends a task-end message** containing that Task's completion-code.  Between task-begin and task-end,** an output-producing Task's output data is produced.  The output data is** bracketed by text-begin and text-end messages.**<p>** When all Tasks are complete, the Envoy sends a stop message** containing the Envoy's status code, i.e. its exit-code.** An EOF on the Envoy stream before a stop message appears is** an indication of failure.**<p>** The default Envoy behavior is to stop performing Tasks as soon as one** of them fails.  That is, as soon as a Task returns a non-zero** completion code or throws an uncaught exception.  The appropriate** text-end, task-end, and stop messages are sent when a Task fails.**<p>** All task and stop messages are in plain ASCII text, one byte per char.** Each message consists of an LF-terminated line, regardless of** the host platform's local line-ending convention.** Each message contains multiple parameters separated by :'s.**<p>**<dl>**  <dt><b>task-begin:N:classname</b></dt>**  <dd>is the task-begin message:**    <dl type="compact">**    <dt><b>task-begin</b></dt>**    <dd>is the literal text "task-begin".</dd>**    <dt><b>N</b></dt>**    <dd>is a decimal sequence number, the task-number, **    starting from 1 and increasing for each task.</dd>**    <dt><b>classname</b></dt>**    <dd>is the fully qualified classname of the Task about to be**    instantiated and performed.</dd>**    </dl>**    The Task has not yet been loaded or**    created when this message is sent.  Therefore, errors arising from Task**    instantiation appear as errors belonging to the failing Task, not as**    errors between Tasks.**    <p>**  </dd>****  <dt><b>text-begin:N</b></dt>**  <dd>is the optional text-begin message:**    <dl type="compact">**    <dt><b>text-begin</b></dt>**    <dd>is the literal text "text-begin".</dd>**    <dt><b>N</b></dt>**    <dd>is a decimal sequence number matching the current task-number.</dd>**    </dl>**    The task's output text follows, until a text-end message.**    If the task does not produce output, this message is not sent for that task.**    <p>**  </dd>****  <dt><b>text-end:N</b></dt>**  <dd>is the optional text-end message:**    <dl type="compact">**    <dt><b>text-end</b></dt>**    <dd>is the literal text "text-end".</dd>**    <dt><b>N</b></dt>**    <dd>is a decimal sequence number matching the current task-number.</dd>**    </dl>**    This message is sent even when the task produced no output,**     but only if a text-begin message was sent before.**    <p>**  </dd>****  <dt><b>task-end:N:status</b></dt>**  <dd>is the task-end message:**    <dl type="compact">**    <dt><b>task-end</b></dt>**    <dd>is the literal text "task-end".</dd>**    <dt><b>N</b></dt>**    <dd>is a decimal sequence number matching the current task-number.</dd>**    <dt><b>status</b></dt>**    <dd>is a decimal number, the Task's status code, which is 0 for success, non-0 for failure.</dd>**    </dl>**    If the task threw an uncaught exception, the status will be -1.**    <p>**  </dd>****  <dt><b>stop:0:status</b></dt>**  <dd>is the stop message:**    <dl type="compact">**    <dt><b>stop</b></dt>**    <dd>is the literal text "stop".</dd>**    <dt><b>0</b></dt>**    <dd>is the apparent task-number, and is always zero.</dd>**    <dt><b>status</b></dt>**    <dd>is a decimal number, the Envoy's exit code, which is 0 for success, non-0 for failure.</dd>**    </dl>**    In general, the Envoy's status is 0 when all Tasks perform() successfully.**    If the Envoy status is not 0, it is generally the status of the last Task, which presumably failed.**    <p>**  </dd>**</dl>**<p>** Subclasses of Envoy can use a different protocol, such as one based on XML.** The messages are sent by specific methods, which can be overridden.** If you use a different protocol, be sure to change the relevant Tool methods, too.** **<h3>System Properties Used</h3>****<dl>**  <dt>"file.encoding"</dt>**  <dd>implicitly used anywhere a PrintStream is created or parsed,**    such as captureUntilEOF(), schlepUntilEOF(), or waitForEnvoy();**    or anywhere encoded bytes are turned into a String,**    such as translateEnvoyMessage().**  </dd>****  <dt>"os.name"</dt>**  <dd>in <b>buildAuth()</b>**    to determine which Authorization class to instantiate.**  </dd>****  <dt>"envoy.tasks.between"</dt>**  <dd>a string value, in <b>perform()</b>**    to mark a task-name when parsing Task-groups from the args.**  </dd>**</dl>** ** @author Gregory Guerin** ** @see Task** @see Tool** @see glguerin.authkit.Authorization*/public class Envoy{	/** The default marker between task-groups in the args received by main() and perform(). */	public static final String TASKS_BETWEEN = ":-";	/** The property name of an override for TASKS_BETWEEN. */	public static final String TASKS_BETWEEN_PROP = "envoy.tasks.between";	/**	** Static entry point, when run as an application.	** It just creates an Envoy instance and lets it do everything.	**<p>	** Normally, this method calls System.exit() with the value returned from finish().	** If the Envoy throws an exception, this method calls System.exit(1),	** after printing a stack-trace to stderr and flushing both output streams.	*/	public static void 	main( String[] args ) 	{		// These are for possible use if Envoy fails.		// Since Envoy's methods may change System's streams, must retain originals here.		PrintStream stdout = System.out;		PrintStream stderr = System.err;		try		{			Envoy self = new Envoy();			self.prepare();			self.perform( args );			System.exit( self.finish() );		}		catch ( Throwable why )		{			stdout.flush();			why.printStackTrace( stderr );			stderr.flush();			// Probably futile, but just in case our exit-status is ever available to parent...			System.exit( 1 );		}	}	/** An Authorization made and attached by prepare(), using buildAuth(). */	private Authorization myAuth;	/** Not used yet. */	private InputStream myIn;	/** This should only be referenced through protocolOut(). */	private PrintStream myOut;	/** Task-number in perform() etc. */	protected int myTaskNumber;	/** Completion status of most recently performed Task: 0 = success, !0 = failure-code. */	protected int myTaskStatus;	/**	** Creates, but does not prepare() it.	*/	public	Envoy()	{  super();  }	/** Emit stack trace on stderr, flushing protocolOut() first. */	public void	explain( Throwable failure )	{		protocolOut().flush();		failure.printStackTrace( System.err );		System.err.flush();	}	/**	** Prepare this Envoy for subsequent use.	**<p>	** This method should prepare the System I/O streams for use with Tasks,	** and arrange to "do protocol" on the default streams, which are presumed to	** be pipes to a parent process.	*/	public void	prepare()	{		// Set up the System streams to "do protocol".		protocolBegins();		// Overridable in subclasses.  No Authorization is yet created or assigned.		prepareTaskIO();		// Last step is to build an appropriate Authorization.		myAuth = buildAuth();	}	/**	** Work through the args and the Tasks,	** communicating results to parent using Envoy protocol over presumed pipe.	** The protocol is performed by taskBegins(), taskEnds(), etc.,	** which are called from taskPerform().	*/	public void	perform( String[] args )	{		String between = System.getProperty( TASKS_BETWEEN_PROP, TASKS_BETWEEN );		// Use a Vector's Enumeration and a 2nd Vector to handle the args.		// It can be done without Vectors, but it's simpler to do the grouping this way.		Enumeration argsEnum = VectorUtil.asVector( args, false ).elements();		Vector taskGroup = new Vector( args.length );		myTaskStatus = 0;		for ( myTaskNumber = 1;  argsEnum.hasMoreElements();  )		{			// Collect arg Strings in emptied taskGroup, as grouped by 'between'.			// If no task-name was identified, continue until argsEnum is exhausted.			// This skips over adjacent between's without causing a failure.			groupTaskArgs( argsEnum, taskGroup, between );			if ( taskGroup.size() != 0 )			{				// If task is not performed successfully, stop doing tasks.				myTaskStatus = taskPerform( myTaskNumber, taskGroup );				if ( myTaskStatus != 0 )					return;				++myTaskNumber;			}		}	}	/**	** Finish doing protocol and anything else.	** Return exit-code that will be passed to System.exit().	**<p>	** By default, does not release() or detach() the Authorization.	** Therefore, the default action occurs on process termination,	** which is equivalent to release().	*/	public int	finish()	{		protocolEnds();		return ( myTaskStatus );	}	//  # # # # #   T A S K S   # # # # #	/**	** Pull one Task-name and a group of args from the given Enumeration,	** placing the String representation of each into the Vector.	** Upon return, the Vector may be empty.	**<p>	** Task-groups are separated by the 'between' String.	** The Vector will not contain either a leading or trailing 'between' String.	*/	protected void	groupTaskArgs( Enumeration argsEnum, Vector taskArgs, String between )	{		// Discard anything previously in taskArgs, then collect		// a group until next between, or end of argsEnum.		for ( taskArgs.removeAllElements();  argsEnum.hasMoreElements();  )		{			String item = argsEnum.nextElement().toString();			if ( item.equals( between ) )				break;			taskArgs.addElement( item );		}	}	/**	** Perform a Task and return its status code: 0 for success, non-zero for all others.	** This method is responsible for all protocol messages regarding the task and its status.	**<p>	** This method calls taskBegins() before it runs the Task,	** followed by taskEnds() or taskFails() afterwards.	** It also calls taskBeginsOutput() and taskEndsOutput() as appropriate.	*/	protected int	taskPerform( int taskNum, Vector taskGroup )	{		// Empty tasks should not get here.		if ( taskGroup.size() == 0 )			throw new IllegalArgumentException( "No Task" );		String taskName = "No Task";		Task task = null;		boolean producesOutput = false;		int status = 0;		try		{			// Pull task's classname from head of Vector.			taskName = taskGroup.firstElement().toString();			taskGroup.removeElementAt( 0 );			// Remainder of Vector, which may be empty, becomes a String array.			String[] taskArgs = new String[ taskGroup.size() ];			taskGroup.copyInto( taskArgs );			// With everything ready to go, tell waiting client that Task is about to begin.			// Do this before instantiating Task, so instantiation failures appear to client			// as coming after the "task begins" message.			taskBegins( taskNum, taskName );			// Instantiate Task using no-args constructor.			task = (Task) Class.forName( taskName ).newInstance();			// Handle Tasks's output-stream needs.			producesOutput = task.producesOutput();			if ( producesOutput )				taskBeginsOutput( taskNum, task );			// Perform the Task and get its completion status.			status = task.perform( taskArgs, getAuthorization() );			// Leave try/catch block before sending status completion message.		}		catch ( Throwable failure )		{			status = -1;			explain( failure );		}		finally		{			// Shut down Task's output-stream, if any.			if ( producesOutput )				taskEndsOutput( taskNum, task );		}		if ( status == 0 )			taskEnds( taskNum, task, status );		else			taskFails( taskNum, task, status );		return ( status );	}	//  # # # # #   A U T H O R I Z A T I O N   # # # # #	/** Return an Authorization, or null if before prepare()'d. */	protected Authorization	getAuthorization()	{  return ( myAuth );  }	/**	** Called from prepare(), build an Authorization for possible subsequent use.	** If unsuccessful, throw an UnauthorizedException.	**<p> 	** The returned Authorization should be attached to a session, if that's	** appropriate for what the Envoy is doing.  Since an Envoy typically operates	** with an effective uid of 'root', and is typically a child process via execPrivileged(),	** the typical attachment is done with attachPrivileged().	** This implementation does that.	**<p>	** This implementation calls newAuth() to make the concrete Authorization,	** then calls attachPrivileged() to attach it.  Therefore, an Envoy by default	** will only run in a child process via execPrivileged().	** This is a reasonable precaution to help prevent accidents,	** such as running Envoy.main() from a normal shell command-line.	*/	protected Authorization	buildAuth()	{		Authorization auth = newAuth();		auth.attachPrivileged();		return ( auth );	}	/**	** The returned Authorization is unattached to any underlying session.	** The available concrete imps are hard-wired here, for security reasons.	**<p>	** If the "os.name" property is "Mac OS X", then a MacOSXAuthorization is returned.	** All other situations, including failure to instantiate a MacOSXAuthorization,	** return a DenyAllAuthorization.	**<p>	** The concrete classes are referenced by name, using Class.forName().	** This avoids invoking an imp's static initializers unless it's actually chosen.	*/	protected Authorization	newAuth()	{		String className = "glguerin.authkit.imp.plain.DenyAllAuthorization";		if ( "Mac OS X".equals( System.getProperty( "os.name" ) ) )			className = "glguerin.authkit.imp.macosx.MacOSXAuthorization";		try		{			// If any of this throws any kind of exception, catch it and fail instead.			return ( (Authorization) Class.forName( className ).newInstance() );		}		catch ( ThreadDeath rethrown )		{  throw rethrown;  }		catch ( Throwable anythingElse )		{  explain( anythingElse );  }		// Log failure and return a DenyAllAuthorization, which is the safest choice.		return ( new glguerin.authkit.imp.plain.DenyAllAuthorization() );	}	/*  # # # # #   P R O T O C O L  # # # # #	**	** The protocol embodied in the following methods is brutally simple.	** It uses simple words of text on a single line, separated by :'s.	**<p>	** A somewhat less brutal approach would use very simple XML.	** It wouldn't necessarily have a DTD and all that stuff, but it could fairly	** easily encode the desired data elements using XML tags.	** The structure of running Tasks and producing output, as well as the	** arrangement of overridable protocol methods, is amenable to XML structure.	** This is left as an exercise for the interested reader, who should remember	** that Tool methods which read and parse the protocol must also be changed.	*/	public static final String PROTOCOL_DELIM = ":";	public static final String PROTOCOL_NEWLINE = "\n";	public static final String PROTOCOL_BEGIN_TASK = "task-begin";	public static final String PROTOCOL_BEGIN_OUTPUT = "text-begin";	public static final String PROTOCOL_END_OUTPUT = "text-end";	public static final String PROTOCOL_END_TASK = "task-end";	public static final String PROTOCOL_STOP = "stop";	/** Return the stdin InputStream piped from controlling parent process, or null if before prepare()'d. */	protected InputStream	protocolIn()	{  return ( myIn );  }	/** Return the stdout PrintStream piped to controlling parent process, or null if before prepare()'d. */	protected PrintStream	protocolOut()	{  return ( myOut );  }	/**	** Set up the streams that will be used to "do protocol" in	** taskBegins(), tasksEnds(), and taskFails(),	** and which will be shut down in an orderly fashion by finish().	**<p>	** If any initial text should be emitted on the protocol streams, do it here.	** This ensures it will occur before the first task begins.	*/	protected void	protocolBegins()	{		myIn = System.in;		myOut = System.out;	}	/**	** Called from prepare(), replace the System I/O streams with ones appropriate for a Task's use.	** This process's default streams, which are piped to another process, have	** already been harnessed to "do protocol" by protocolBegins().	*/	protected void	prepareTaskIO()	{		System.setOut( new PrintStream( new SinkOutputStream() ) );		System.setIn( new ByteArrayInputStream( new byte[ 0 ] ) );	}	/**	** Called from finish(), send any Envoy-termination messages, and then	** shut down the I/O streams used to "do protocol".	** "Shut down" doesn't necessarily mean the streams are closed.	** It may just mean the streams are flushed, as here.	*/	protected void	protocolEnds()	{		PrintStream out = protocolOut();		out.print( PROTOCOL_STOP + PROTOCOL_DELIM + "0" + PROTOCOL_DELIM + myTaskStatus );		out.print( PROTOCOL_NEWLINE );		out.flush();	}	/**	** Send a BEGIN_TASK protocol message.	*/	protected void	taskBegins( int taskNum, String taskName )	{		PrintStream out = protocolOut();		out.print( PROTOCOL_BEGIN_TASK + PROTOCOL_DELIM + taskNum + PROTOCOL_DELIM + taskName );		out.print( PROTOCOL_NEWLINE );		out.flush();	}	private PrintStream wasOut = null;	/**	** Send a BEGIN_OUTPUT protocol message, then redirect System.out	** to a stream ready for the Task to produce its output on.	** If the Task does not write anything to System.out, then its results will be empty.	** This is acceptable as far as the protocol is concerned.	*/	protected void	taskBeginsOutput( int taskNum, Task task )	{		if ( wasOut != null )			throw new IllegalStateException();		PrintStream out = protocolOut();		out.print( PROTOCOL_BEGIN_OUTPUT + PROTOCOL_DELIM + taskNum );		out.print( PROTOCOL_NEWLINE );		out.flush();		wasOut = System.out;		System.setOut( protocolOut() );	}	/**	** Shut down the System.out used by the Task,	** sending any protocol messages to mark the end of Task output.	*/	protected void	taskEndsOutput( int taskNum, Task task )	{		System.out.flush();		PrintStream was = wasOut;		wasOut = null;		if ( was == null )			throw new IllegalStateException();		System.setOut( was );		PrintStream out = protocolOut();		out.print( PROTOCOL_END_OUTPUT + PROTOCOL_DELIM + taskNum );		out.print( PROTOCOL_NEWLINE );		out.flush();	}	/**	** Send an END_TASK message.	**<p>	** The Task should not be null.	*/	protected void	taskEnds( int taskNum, Task task, int status )	{		PrintStream out = protocolOut();		out.print( PROTOCOL_END_TASK + PROTOCOL_DELIM + taskNum + PROTOCOL_DELIM + status );		out.print( PROTOCOL_NEWLINE );		out.flush();	}	/**	** Send an END_TASK message.	**<p>	** The Task may be null, so qualify before using it.	*/	protected void	taskFails( int taskNum, Task task, int status )	{		PrintStream out = protocolOut();		out.print( PROTOCOL_END_TASK + PROTOCOL_DELIM + taskNum + PROTOCOL_DELIM + status );		out.print( PROTOCOL_NEWLINE );		out.flush();	}}