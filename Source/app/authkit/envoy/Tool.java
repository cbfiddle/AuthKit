/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.envoy;import java.awt.Frame;import java.io.*;import java.util.*;import app.util.FileDialogger;import app.util.BasicAlert;import glguerin.authkit.*;import glguerin.util.*;// --- Revision History ---// 17Jul2003 GLG  create// 21Jul2003 GLG  add more support methods for subclasses// 22Jul2003 GLG  add basic Envoy-protocol support// 25Jul2003 GLG  distinguish failure reasons in mustBeAppBundle()// 25Jul2003 GLG  add failed()// 06Aug2003 GLG  add stripPrefixed()// 09Aug2003 GLG  add presupposeProperty()/**** A Tool is a class that runs a privileged Envoy process and presents the results.** It encapsulates the unprivileged side of peforming privileged Tasks** using an Authorization.**<p>** Typically, a concrete Tool subclass is given a purpose-specific perform() method** along with a completely generalized main() method that calls perform().** But this is only typical, not required.** You don't have to give your Tool class a main() method.** You don't have to give it a meaningful perform() method.** You don't even have to use a Tool class at all to run a privileged Envoy process.** It's just a convenient way to do so.**<p>** A Tool may represent only a command-line program, only a GUI program,** or both, or neither.  Some Tool methods refer to AWT classes, but you** don't have to use them if you don't want to.  If you want to use Swing classes,** or some other GUI's classes, you can do that.**<p>** Most Tool methods are utility or support methods for doing the things** a Tool should do on behalf of an Envoy process:**<ul>**  <li>creating a concrete Authorization</li>**  <li>preauthorizing the user, as appropriate</li>**  <li>selecting a target item interactively, as appropriate</li>**  <li>building a complete 'java' command-line to run an Envoy process</li>**  <li>reading and parsing Envoy-protocol results</li>**  <li>presenting alerts, as appropriate</li>**</ul>****<h3>System Properties Used</h3>****<dl>**  <dt>"file.encoding"</dt>**  <dd>in <b>addJavaCommand()</b>**    as a predefined property when building the Envoy process's command-line.**    Also implicitly used anywhere a PrintStream is created or parsed,**    such as captureUntilEOF(), schlepUntilEOF(), or waitForEnvoy();**    or anywhere encoded bytes are turned into a String,**    such as translateEnvoyMessage().**  </dd>****  <dt>"java.class.path"</dt>**  <dd>in <b>addJavaCommand()</b>**    as the "-cp" parameter when building a 'java' command-line.**  </dd>****  <dt>"java.home"</dt>**  <dd>in <b>getJavaPath()</b>**    to determine where javaCommand is located, to construct an absolute pathname.**  </dd>****  <dt>"os.name"</dt>**  <dd>in <b>newAuth()</b>**    to determine which Authorization class to instantiate.**  </dd>****  <dt>"envoy.tasks.between"</dt>**  <dd>a string value, in <b>addEnvoyTask()</b>**    to precede the task-name when building an Envoy-process command-line.**  </dd>****  <dt>"alert"</dt>**  <dd>a boolean value, in <b>alert()</b>**    to decide whether to present a BasicAlert or to do nothing.**    If alert() isn't called, this property has no effect.**  </dd>****  <dt>"no-exit"</dt>**  <dd>a boolean value, in <b>depart()</b>**    to decide whether to call System.exit() or throw a ThreadDeath.**    If depart() isn't called, this property has no effect.**  </dd>**</dl>**** @author Gregory Guerin**** @see Envoy*/abstract public class Tool{	/** Typical main(), as defined in your Tool subclass. */	/*	public static void 	main( String[] args ) 	{  new ToolSubclass().perform( args );  }	*/	/** Emit line of text on stdout. */	public void	tell( String toTell )	{  System.out.println( toTell );  }	/** Emit line of text on stderr, flushing stdout first. */	public void	explain( String text )	{		System.out.flush();		System.err.println( text );		System.err.flush();	}	/** Emit stack trace on stderr, flushing stdout first. */	public void	explain( Throwable toExplain )	{		System.out.flush();		toExplain.printStackTrace( System.err );		System.err.flush();	}	/** Accessible only to subclasses. */	protected	Tool()	{  super();  }	/**	** Perform this Tool's actions on the given args.	** Typically called by a concrete Tool's main() method:	**<pre>		public static void 		main( String[] args ) 		{  new ToolSubclass().perform( args );  }	**</pre>	*/	abstract public void 	perform( String[] args );	/**	** Calls exit() or throws ThreadDeath, depending on "no-exit" property.	*/	public void 	depart( int status )	{		if ( Boolean.getBoolean( "no-exit" ) )		{			System.err.println( "depart: " + status );			throw new ThreadDeath();		}		else			System.exit( status );	}	/**	** If the system property named by propName is already defined, do nothing.	** Otherwise, define it to have the non-null propValue.	**<p>	** This is useful when interaction, such as a FileDialog, presupposes subsequent interaction	** is desirable, such as controlled by the "alert" property.	*/	protected void 	presupposeProperty( String propName, String propValue )	{		if ( System.getProperty( propName ) == null )			System.getProperties().put( propName, propValue );	}	/**	** The returned Authorization is unattached to any underlying session.	** The available concrete imps are hard-wired here, for security reasons.	**<p>	** If the "os.name" property is "Mac OS X", then a MacOSXAuthorization is returned.	** All other situations, including failure to instantiate a MacOSXAuthorization,	** return a DenyAllAuthorization.	**<p>	** The concrete classes are referenced by name, using Class.forName().	** This avoids invoking an imp's static initializers unless it's actually chosen.	*/	protected Authorization	newAuth()	{		String className = "glguerin.authkit.imp.plain.DenyAllAuthorization";		if ( "Mac OS X".equals( System.getProperty( "os.name" ) ) )			className = "glguerin.authkit.imp.macosx.MacOSXAuthorization";		try		{			// If any of this throws any kind of exception, catch it and fail instead.			return ( (Authorization) Class.forName( className ).newInstance() );		}		catch ( ThreadDeath rethrown )		{  throw rethrown;  }		catch ( Throwable anythingElse )		{  explain( anythingElse );  }		// Log failure and return a DenyAllAuthorization, which is the safest choice.		return ( new glguerin.authkit.imp.plain.DenyAllAuthorization() );	}	/**	** Strip nulls and Strings that start with prefix, returning a String[].	** If no Strings start with prefix, the original array is returned.	** Useful in other cases, but mainly for stripping "-psn_*" from args.	*/	protected String[]	stripPrefixed( String[] array, String prefix )	{		Vector vector = new Vector( array.length );		for ( int i = 0;  i < array.length;  ++i )		{			String item = array[ i ];			if ( item != null  &&  ! item.startsWith( prefix ) )				vector.addElement( item );		}		if ( vector.size() != array.length )		{			// Turn the Vector into a String array.			array = new String[ vector.size() ];			vector.copyInto( array );		}		return ( array );	}	/**	** Create a new nonce Frame that isn't intended to be shown,	** but is only needed as an anchor for a Component or Dialog hierarchy.	** Called by chooseTarget() and alert().	**	** @see #chooseTarget	** @see #alert	*/	protected Frame 	nonceFrame()	{		Frame nonce = new Frame();		nonce.setResizable( false );		return ( nonce );	}	/**	** Choose a target to operate on by presenting a FileDialog.	** The prompt and kind determine the FileDialog displayed.	** The resulting selection is returned as a String[], or null if cancelled.	**	** @see app.util.FileDialogger	*/	protected String[] 	chooseTarget( String prompt, int kind )	{		// Make and show FileDialog, getting result, which may be null.		File result = FileDialogger.runFileDialog( nonceFrame(), prompt, kind );		if ( result == null )  // cancelled			return ( null );		// Return String[] holding absolute path.		return ( new String[] { result.getAbsolutePath() } );	}	/**	** If an app-bundle, return canonical absolute pathname with symlinks resolved.	** If not an app-bundle, throw an IOException whose message summarizes why.	**<p>	** This implementation requires the following for success:	**<ol>	**  <li>the target must exist and be accessible</li>	**  <li>the target must be a directory</li>	**  <li>there must be a file "Contents/PkgInfo" nested inside the target directory</li>	**  <li>the PkgInfo file must be readable and at least 8 bytes long</li>	**  <li>the PkgInfo file must contain 'APPL' as its first 4 bytes.</li>	**  <li>the target directory must be resolveable by getCanonicalPath()</li>	**</ol>	*/	public String	mustBeAppBundle( String filename )	  throws IOException	{		File appBundle = new File( filename );		// Could check leaf-name for ".app" suffix, but that has relatively little weight.		// Don't check for bundle-bit, since it's inconsequential to Finder's determination.		// There's no way to check bundle-bits in plain Java, either.		if ( ! appBundle.exists() )			throw new IOException( "No such file or directory: " + appBundle.getAbsolutePath() );		if ( ! appBundle.isDirectory() )			throw new IOException( "Not a bundle directory: " + appBundle.getAbsolutePath() );		// "Contents/PkgInfo" must be a file, 8 bytes or longer.		File pkgInfo = new File( appBundle, "Contents" + File.separator + "PkgInfo" );		if ( ! pkgInfo.isFile()  ||  pkgInfo.length() < 8 )			throw new IOException( "Missing or truncated Contents/PkgInfo file: " + appBundle.getAbsolutePath() );		// Read PkgInfo's contents and check for 'APPL' type at offset 0.		// IOExceptions thrown by constructor won't close(), and have an adequate message as-is.		RandomAccessFile data = new RandomAccessFile( pkgInfo, "r" );		try		{			if ( data.readInt() != 0x4150504C )  // 0x4150504C == 'APPL'				throw new IOException( "Not an app-bundle: " + appBundle.getAbsolutePath() );		}		finally		{  data.close();  }		// This may yet throw an IOException, though it's unlikely if we get this far.		// If were checking for ".app" suffix, it should happen after canonicalization, so		// symlinks, etc. are resolved.  Otherwise we wouldn't be testing the canonical leaf-name.		return ( appBundle.getCanonicalPath() );	}	/**	** Build a complete command-line to run envoyClass.main() in another process.	*/	protected String[] 	makeEnvoyCommand( String javaCmd, String[] jvmArgs,			String envoyClass, String envoyPrefix,			String taskName, String[] taskArgs )	{		if ( envoyClass == null )			throw new IllegalArgumentException( "Needs non-null envoyClass" );		Vector cmd = new Vector( 7 );		// Start building a 'java' command-line...		addJavaCommand( cmd, javaCmd, jvmArgs );		// Add properties that match envoyPrefix...		addPrefixedProperties( cmd, envoyPrefix );		// Add the Envoy class-name as the command's main-class.		cmd.addElement( envoyClass );		// Add the Task and its args		addEnvoyTask( cmd, taskName, taskArgs );		// Turn the Vector into a String array.		String[] array = new String[ cmd.size() ];		cmd.copyInto( array );		return ( array );	}	/**	** Make an absolute pathname representing a Java interpreter command.	** It is formed by taking the "java.home" property's value and	** appending the supplied String with a File.separator between them.	** If the given String is empty or null, append "bin/java", using appropriate File.separator.	*/	protected String	getJavaPath( String javaCommand )	{		// Always append a separator, since java.home may not end in "/".		// This ensures that javaCommand will always be interpreted relative to java.home.		StringBuffer build = new StringBuffer( System.getProperty( "java.home" ) );		build.append( File.separator );		if ( javaCommand != null  &&  javaCommand.length() != 0 )			build.append( javaCommand );		else			build.append( "bin" ).append( File.separator ).append( "java" );		return ( build.toString() );	}	/**	** Start building a 'java' command-line.	** On return, the Vector contains the command itself,	** the classpath designation (inherited from self),	** a "-Dfile.encoding=xxx"	** so the new process will share this process's default text-encoding,	** and all the non-null values in jvmArgs.	*/	protected void 	addJavaCommand( Vector command, String javaCommand, String[] jvmArgs )	{		// ## Dummy command: echos all other args to stdout, separated by a space.//		command.addElement( "/bin/echo" );		// The absolute pathname of the appropriate 'java' command.		command.addElement( getJavaPath( javaCommand ) );		// The classpath must be the same as myself.		command.addElement( "-cp" );		command.addElement( System.getProperty( "java.class.path" ) );		// The text-encoding must be the same as myself, so his PrintStreams encode		// to what I'm initially expecting to read or write on the Envoy-protocol streams.		addOneProperty( command, "file.encoding" );		// Add additional jvmArgs or properties, if any, without adding nulls...		VectorUtil.addToVector( command, jvmArgs, false );	}	/**	** System properties starting with propPrefix are -D'ed onto Vector.	** A null propPrefix adds no properties.	** An empty propPrefix adds them all.	*/	protected void 	addPrefixedProperties( Vector command, String propPrefix )	{		if ( propPrefix != null )		{			// The system properties starting with propPrefix are predefined in new command.			Enumeration names = System.getProperties().propertyNames();			while ( names.hasMoreElements() )			{				String name = names.nextElement().toString();				if ( name.startsWith( propPrefix ) )					addOneProperty( command, name );			}		}	}	/** If property's value is non-null, add a "-Dxx=yy" to the Vector. */	protected void 	addOneProperty( Vector command, String propName )	{		if ( propName != null )		{			String value = System.getProperty( propName );			if ( value != null )				command.addElement( "-D" + propName + "=" + value );		}	}	/**	** Add inter-Task marker, taskName, and taskArgs to cmd Vector.	** Uses the "envoy.tasks.between" property as the inter-Task marker,	** or Envoy.TASKS_BETWEEN as the marker's default.	*/	protected void	addEnvoyTask( Vector cmd, String taskName, String[] taskArgs )	{		// Mark task-name with a preceding Envoy.TASKS_BETWEEN,		// or the value of the "envoy.tasks.between" property.		cmd.addElement( System.getProperty( "envoy.tasks.between", Envoy.TASKS_BETWEEN ) );		// If taskName is null, then presume first item in taskArgs is task-name.		if ( taskName != null )			cmd.addElement( taskName );		// Add taskArgs, if any, without adding nulls...		VectorUtil.addToVector( cmd, taskArgs, false );	}	/**	** Wait for EOF on InputStream, schlepping everything received to OutputStream	** and capturing the last captureSize bytes to be returned.	** Neither stream is closed.	** Calls schlepUntilEOF().	*/	protected byte[] 	captureUntilEOF( InputStream in, OutputStream out, int captureSize )	  throws IOException	{		if ( out == null )			out = new SinkOutputStream();		CaptureOutputStream capture = new CaptureOutputStream( out, captureSize );		schlepUntilEOF( in, capture );		return ( capture.getCaptured() );	} 	/**	** Wait for EOF on InputStream, schlepping everything received to OutputStream,	** using the current Thread rather than an asynchronous daemon Thread.	** The number of bytes transferred is returned.	** Neither stream is closed.	*/	protected long 	schlepUntilEOF( InputStream in, OutputStream out )	  throws IOException	{  return ( new Streamer( new byte[ 4 * 1024 ],  in, false,  out, false, true ).pump() );  }	/**	** Translate a portion of an Envoy-protocol communication into String form.	** The portion is typically a captured section, so its bytes may not encode complete	** characters, if it is in a multi-byte encoding.  For safety, though at some loss of robustness,	** this method first translates all bytes in the range 0x80-0xFF into ?'s as substitutes.	** That is, all negative bytes are transformed into single-byte characters.	**<p>	** The given byte[] is modified before being turned into a String.	** The byte[] is encoded using the default encoding (i.e. "file.encoding").	*/	protected String	translateEnvoyMessage( byte[] bytes )	{		// Translate all bytes < 0 into ?'s (0x3F), for safety in conversion to String.		// UTF8 in particular can be unhappy with fragments of multi-byte sequences.		for ( int i = 0;  i < bytes.length;  ++i )		{			if ( bytes[ i ] < 0 )				bytes[ i ] = (byte) 0x3F;		}		// In default text-encoding, presumed to be the same as protocol with Envoy process.		return ( new String( bytes ) );	}	/**	** Extract an Envoy message identified by marker, from the text starting at index.	** The message begins at the first appearance of the marker, and ends at the	** first following appearance of Envoy.PROTOCOL_NEWLINE.	** The message is then separated into parts by Envoy.PROTOCOL_DELIM, which are	** returned as an Object[] containing String and Integer values.	**<p>	** The index tells where to start scanning the text for the marker, and in which direction.	** Non-negative values count from the start of the text	** and scan towards the end.	** Negative index values count from past the end of the text	** and scan towards the start.	** So -1 means the last char, -2 the next to last, etc.	** The Envoy.PROTOCOL_NEWLINE always follows the marker, so it is always	** searched for by scanning towards the end of the text.	**<p>	** Returns an array containing mixed String and/or Integer values.	** Any piece that can be converted to an Integer is returned as an Integer.	** Any piece that can't be converted to an Integer is returned as a String.	**<p>	** <B>	** This method uses Envoy's protocol strings, and relies on knowledge of their format.	** If the Envoy protocol is changed, this method must also change.	** </B>	*/	protected Object[]	getEnvoyMessageParts( String text, int index, String marker )	{		// Holds index where marker is first found in scan.		int head;		// Scan backward from end, or forward from start.		if ( index < 0 )			head = text.lastIndexOf( marker, text.length() + index );		else			head = text.indexOf( marker, index );		if ( head < 0 )			return ( null );  // not found		int tail = text.indexOf( Envoy.PROTOCOL_NEWLINE, head );		if ( tail < 0 )			return ( null );  // not found		// Does not extract the newline, because endIndex (tail) is non-inclusive.		String message = text.substring( head, tail );				// Split the Envoy's message into parts at PROTOCOL_DELIM's.		// Decimal numbers are returned as Integer, everything else as String.		StringTokenizer splitter = new StringTokenizer( message, Envoy.PROTOCOL_DELIM );		Object[] parts = new Object[ splitter.countTokens() ];		for ( int i = 0;  i < parts.length; ++i )		{			// Always store token's String form as default.			parts[ i ] = splitter.nextToken();			// If parseable as a decimal number, store the Integer over the String.			// A NumberFormatException is ignored, since parts[i] already holds			// the String if number is unparseable or out-of-range.			try			{  parts[ i ] = new Integer( Integer.parseInt( parts[ i ].toString() ) );  }			catch ( NumberFormatException ignored )			{  /* IGNORED */  }		}		return ( parts );	}	/**	** Wait for an Envoy-protocol 'stop' message on InputStream, echoing the data	** to the OutputStream, and parsing the Envoy's final status from the data.	**<p>	** If the OutputStream is null, the Envoy protocol stream is parsed	** for an Envoy STOP message, but otherwise consumed.	**<p>	** Parsing failures throw an IOException whose message summarizes the reason for failure.	** <B>	** This method relies on knowledge of Envoy's protocol format,	** The PROTOCOL_STOP message in particular.	** If the Envoy protocol is changed, this method must also change.	** </B>	*/	protected int	waitForEnvoy( InputStream in, OutputStream out )	  throws IOException	{		// The last 40 bytes are captured and scanned for the "stop" marker.		// For safety, translate all neg bytes into ?'s, then search for last PROTOCOL_STOP.		String tailStr = translateEnvoyMessage( captureUntilEOF( in, out, 40 ) );		Object[] parts = getEnvoyMessageParts( tailStr, -1, Envoy.PROTOCOL_STOP );		// Optional diagnostic aid		if ( false )		{			System.out.flush();			System.err.println( "----" );			System.err.println( tailStr );			System.err.println( "----" );		}		// Was there a discernible STOP message?		if ( parts == null )			throw new IOException( "Envoy protocol failure: no STOP message" );		// Does the message have enough parts?		if ( parts.length < 3 )			throw new IOException( "Envoy protocol failure: short parts: " + parts.length );		// Is part[1] a constant zero number?		if ( ((Number) parts[ 1 ]).intValue() != 0 )			throw new IOException( "Envoy protocol failure: bad indicator: " + parts[ 1 ] );		// Return the status number.		return ( ((Number) parts[ 2 ]).intValue() );	}	/** Emit to stderr, then call alert(). */	protected void	failed( Throwable why, boolean stackTrace, String alertTitle )	{		// If no message, make one from exception's class name.		String summary = why.getMessage();		if ( summary == null  ||  summary.length() == 0 )			summary = "Caught: " + why.getClass().getName();		// Always explain(), but choose between full and brief results.		if ( stackTrace )			explain( why );		else			explain( summary );		// Cover alert presentation, if any.		alert( alertTitle, new Object[] { summary } );	}	/**	** Show a modal BasicAlert if "alert" property is true, or do nothing if it's false.	** The BasicAlert has a 5- to 12-line by 50-char text-area,	** with no scrollbars or only a vertical one.	** The alertText will be added as lines, one for each Object.toString().	** If a String contains newlines, those will be additional lines.	** The supplied alertText lines will be wrapped to fit, though not necessarily word-wrapped.	**<p>	** If you need a more flexible BasicAlert, make your own or define an override.	*/	protected void	alert( String alertTitle, Object[] alertLines )	{		// If alert is desired, do it.		if ( Boolean.getBoolean( "alert" ) )		{			int lines = alertLines.length;			int scrollbars = 0;  // 0 means "none", as God intended.			if ( lines < 5 )  {  lines = 5;  }			if ( lines > 12 )  {  lines = 12;  scrollbars = BasicAlert.SCROLL_VERT;  }			StringBuffer text = new StringBuffer();			for ( int i = 0;  i < alertLines.length;  ++i )			{				Object item = alertLines[ i ];				if ( item != null )					text.append( item.toString() ).append( "\n" );			}			// Nonce Frame isn't shown, but needed for Component hierarchy.			new BasicAlert( nonceFrame(), alertTitle, true,					text.toString(), lines, 50, scrollbars,					0.25F, 0.5F ).show();		}	}}