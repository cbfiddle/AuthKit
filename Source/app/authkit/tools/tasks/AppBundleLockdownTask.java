/*** Copyright 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.tools.tasks;import java.io.*;import glguerin.authkit.*;// --- Revision History ---// 23Jul2003 GLG  create stub// 24Jul2003 GLG  clear setuid/setgid bits throughout app-bundle// 24Jul2003 GLG  clean up// 25Jul2003 GLG  preserve setgid bit// 28Jul2003 GLG  revise error-reporting when exit-codes are non-zero// 06Aug2003 GLG  use "-exec /bin/rm {} \;" instead of "-delete" as /usr/bin/find primary// 08Aug2003 GLG  refactor, expand doc-comments/**** AppBundleLockdownTask is a Task that locks down app-bundles.** It is perform()'ed by a privileged Envoy process, launched by AppBundleLockdown.**<p>** When traversing the app-bundle, symlinks are not followed, nor are alias-files resolved.** The app-bundle pathname may be a symlink, and it WILL be followed.**<p>** Everything in the app-bundle has its setuid and all write-permissions removed.** All other permissions (setgid, sticky, read, and execute/search) are unchanged.** In effect, the POSIX permissions of each file and directory are AND'ed with 03555 (octal).**<p>** Everything in the app-bundle has its owner changed to 'root'.** The group is not changed on any file or directory.**<p>** The setuid bits are removed to eliminate the possibility of a program** gaining elevated privileges simply by** having its setuid bit set before changing ownership to 'root',** and then becoming setuid-root as a consequence of the ownership change.**<p>** The setgid bit is not changed. ** This poses no added security risk, because the group is not changed.** So even if a Trojan-horse file with setgid set was present, there would be no** unexpected setgid consequences since there is no change.**<p>** The commands executed by this Task are platform-specific to Mac OS X.** Other Unix-like platforms will have similar commands, but their location and options may differ.** I have no idea if Windows has similar commands, nor what they might be.**<p>** The shell-equivalents of the commands executed are:**<pre>	/usr/bin/find -Pdx $ARG -name '.*DS_Store' -type f -exec /bin/rm '{}' ';'	/bin/chmod -RP u-s,a-w $ARG	/usr/sbin/chown -RP root $ARG**</pre>** Each $ARG is replaced by the pathname of the target app-bundle.** The 'find' primary "-delete" isn't used because it's only available on 10.2+.** Absolute command pathnames are used to preclude PATH spoofing.****<h3>System Properties Used</h3>****<dl>**  <dt>"envoy.keep.DS_Store"  (boolean, default false)</dt>**  <dd>**    should all '.*DS_Store' files in app-bundle be kept (T) or deleted (F)?**  </dd>****</dl>**** @author Gregory Guerin*/public class AppBundleLockdownTask  extends CommonTask{	/** Pattern in command-templates to replace with the target arg. */	private static final String REPLACE = "$ARG";	/*		/usr/bin/find -Pdx  $ARG  -name '.*DS_Store'  -type f  -exec /bin/rm '{}' ';'		/usr/bin/find -Pdx  $ARG  -name '.*DS_Store'  -type f  -delete    -Pdx = symlinks not followed (P); depth-first traversal (d), don't cross device boundaries (x)	$ARG = pathname of subtree to search    -name '.*DS_Store' = node's leaf-name matches shell-pattern ".*DS_Store" (quoting is only for shell)    -type f = node-type is "ordinary file"    -exec /bin/rm '{}' ';' = delete the node (if non-root, must have write permission on dir)	*/	private static String[] DELETER =		{  "/usr/bin/find", "-Pdx", "$ARG",  "-name", ".*DS_Store",  "-type", "f",  "-exec", "/bin/rm", "{}", ";"  };//		{  "/usr/bin/find", "-Pdx", "$ARG",  "-name", ".*DS_Store",  "-type", "f",  "-delete"  };	/*		/bin/chmod -RP a-w  $ARG	    -RP = recursive (R), symlinks never followed (P)	    u-s,a-w = remove setuid (u-s), remove all 'write' permissions (a-w)		$ARG = pathname of subtree to traverse	*/	private static String[] CHMOD =		{  "/bin/chmod", "-RP", "u-s,a-w", "$ARG"  };	/*		/usr/sbin/chown -RP root $ARG	    -RP = recursive (R), symlinks never followed (P)	    root = root owner, unchanged group		$ARG = pathname of subtree to traverse	*/	private static String[] CHOWN =		{  "/usr/sbin/chown", "-RP", "root", "$ARG"  };	/**	** Perform the actions embodied in this Task, returning a completion-code,	** which an Envoy then returns to its master.	**<p>	** A value of zero means "success".  Non-zero values mean some kind of failure.	** If this method throws any exceptions, that is also considered a failure.	**<p>	** This method enforces the underlying Authorization policy rules by calling	** authorize() before anything is done.  The Privilege is a root-execute Privilege	** created by makeExecPrivilege(), without a command-name.  We could authorize()	** each command before exec()'ing it, but that seems a little too much.	**<p>	** If this Task was doing something that should have its own named Privilege,	** then we'd use that application-specific named Privilege.  Since there isn't a	** specific Privilege, other than the general root-exec one, that's what we authorize().	**<p>	** The authorize() call is not permitted user-interaction, because this code should not	** be running interactively.  Either we already have the Privilege granted, or it's	** implied by the effective-uid of root, but we do not allow user authentication now.	** If it fails, it fails, and the Envoy will terminate appropriately.	**<p>	** This use of authorize() is the typical approach to guarding a restricted section of code.	** Do not omit it just because you think it's safe to assume it's running as root.	** Good security means not making assumptions.	*/	public int	perform( String[] args, Authorization auth )	{		// Enforce the security design using authorize().		// Use the root-exec Privilege without a command-name.		Privilege needed = auth.makeExecPrivilege( null );		auth.authorize( needed, false );		// The boolean property "envoy.keep.DS_Store" controls .DS_Store deletion.		// The files are kept (not deleted) only when the property is true.		// If the property is missing, false, or non-boolean, the files are deleted.		// Removing .DS_Store files inside an app-bundle is a reasonable default here,		// especially considering everything else we're doing to the app-bundle.		boolean keep_DS_Store = Boolean.getBoolean( "envoy.keep.DS_Store" );		// Will indicate success if there are no args processed.		int status = 0;		// Perform for every arg, where each one should be a valid pathname.		for ( int i = 0;  i < args.length;  ++i )		{			String target = args[ i ];			// Diagnostic goes to stderr, not stdout.			explain( "Locking down: " + target );			// If not keeping DS_Store files, delete them.			if ( ! keep_DS_Store )			{				status = execute( DELETER, REPLACE, target );				if ( status != 0 )					break;			}			status = execute( CHMOD, REPLACE, target );			if ( status != 0 )				break;			status = execute( CHOWN, REPLACE, target );			if ( status != 0 )				break;		}		return ( status );	}	/**	** Treat progTemplate as a command template to substitute then execute.	** The Process's stdout is consumed.	** Its stderr is sent to my stderr.	** Its exit-status is returned.	** If the exit-status is non-zero, a message is emitted on stderr.	*/	private int	execute( String[] progTemplate, String pattern, String replacement )	{		String[] cmd = substitute( progTemplate, pattern, replacement );		int status = execute( cmd, null, null, System.err );  // cmd-array, no stdin, no stdout, shared stderr		if ( status != 0 )			explain( cmd[ 0 ] + ": failed with exit code " + status );		return ( status );	}}