/*** Copyright 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.tools.tasks;import java.io.*;import glguerin.authkit.*;import glguerin.util.Streamer;// --- Revision History ---// 24Jul2003 GLG  create, refactored from other classes/**** CommonTask is a partial Task implementation used as a base-class.** It defines a default implementation of producesOutput() that returns false.** Only Tasks that produce output need to provide an override.** No definition of perform() is provided, so all CommonTasks must define it.**<p>** CommonTask also provides utility methods useful to Tasks that execute external programs.** Many Tasks are written to run other programs as root, so these simplify such Tasks.**** @author Gregory Guerin*/abstract public class CommonTask  implements app.authkit.envoy.Task{	/**	** Visible only to subclasses.	*/	protected	CommonTask()	{  super();  }	/**	** Does this Task produce output on System.out that should be collected	** and returned to the Envoy's master?	**<p>	** Returns false.	** Only subclasses that produce output need to override.	*/	public boolean	producesOutput()	{  return ( false );  }	/** Emit line of text on stderr, flushing stdout first. */	protected void	explain( String text )	{		System.out.flush();		System.err.println( text );		System.err.flush();	}	/** Emit stack trace on stderr, flushing stdout first. */	protected void	explain( Throwable toExplain )	{		System.out.flush();		toExplain.printStackTrace( System.err );		System.err.flush();	}	/**	** Replicate progArray, substituting each occurrence of pattern with replacement.	** The pattern must be a distinct String in progArray.	** It may appear multiple times.	** Sub-patterns within progArray Strings do not undergo pattern substitution.	*/	protected String[]	substitute( String[] progArray, String pattern, String replacement )	{		// First, make shallow copy of array (all arrays are cloneable).		String[] replica = (String[]) progArray.clone();		for ( int i = 0;  i < replica.length;  ++i )		{			if ( pattern.equals( replica[ i ] ) )				replica[ i ] = replacement;		}		return ( replica );	}	/**	** Treat the progArray as a command to execute with Runtime.exec(),	** feeding the Process's streams to the given streams	** using independent daemon threads running a glguerin.util.Streamer.	**<p>	** The Process's input-consuming stream is fed by the given InputStream,	** or is unfed if the stream is null.  To cause the Process to see an immediate EOF,	** you should provide a non-null InputStream that will return an immediate EOF.	** For example, provide a ByteArrayInputStream wrapping a byte[0].	**<p>	** If an OutputStream is null, the Process's output destined for that stream is discarded.	** Otherwise the bytes are written to the provided OutputStream using a Streamer.	**<p>	** None of the streams provided are closed by the Streamer threads that move the data.	** All the Streamer threads are daemon Threads in the current ThreadGroup.	**<p>	** The Process's exit-status is returned,	** or -1 if can't exec() it,	** or -2 if can't waitFor() it.	** An unchecked exception may also be thrown.	*/	protected int	execute( String[] progArray, InputStream stdin, OutputStream stdout, OutputStream stderr )	{		try		{			// Create the Process exactly as given.			Process child = Runtime.getRuntime().exec( progArray );			// Its streams always get schlepped to stdout and stderr as given.			Streamer schlepper = new Streamer( new byte[ 4 * 1024 ],					child.getInputStream(), false,  stdout, false, true );			schlepper.makeDaemon( null, "Cmd-stdout-schlepper" ).start();			schlepper = new Streamer( new byte[ 1024 ],					child.getErrorStream(), false,  stderr, false, true );			schlepper.makeDaemon( null, "Cmd-stderr-schlepper" ).start();			// The input stream is only applied if stdin is non-null.			if ( stdin != null )			{				// If stdin is provided, assume the Process is expecting an EOF on its stdin in order				// to signal the end of input.  Hence the 'true' as the closeOutput boolean.				schlepper = new Streamer( new byte[ 1024 ],						stdin, false,  child.getOutputStream(), true, true );				schlepper.makeDaemon( null, "Cmd-stdin-schlepper" ).start();			}			// Wait for Process termination.			return ( child.waitFor() );		}		catch ( IOException why )		{  return ( -1 );  }		catch ( InterruptedException why )		{  return ( -2 );  }	}}