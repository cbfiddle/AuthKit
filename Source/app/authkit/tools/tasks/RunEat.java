/*** Copyright 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.tools.tasks;import java.io.*;import glguerin.authkit.*;// --- Revision History ---// 23Jul2003 GLG  create// 08Aug2003 GLG  expand doc-comments/**** RunEat runs arbitrary commands, whose output is ultimately consumed.**** @author Gregory Guerin*/public class RunEat  extends CommonTask{	/** Create a do-anything Task. */	public	RunEat()	{  super();  }	/**	** Treat the args as a command to execute, with its args.	** The Process's stdout is sent to System.out.	** It's exit-status is my return status.	**<p>	** Although we send the Process's stdout to my System.out, we don't declare	** this as an output-producing Task with producesOutput().  As a result, the output	** is ultimately sent to a bit-bucket stream set up by Envoy.	** The reason for doing it this way is so RunOut can be implemented simply by	** returning true from producesOutput(), while still using this same perform().	** The two classes are thus interdependent, but that's fine for these two fellows.	**<p>	** This method enforces the underlying Authorization policy rules by calling authorize().	** The Privilege is a root-execute Privilege created by makeExecPrivilege(), with	** the command-name taken from args[0].  This is exactly the Privilege to use here.	**<p>	** The authorize() call is not permitted user-interaction, because this code should not	** be running interactively.  Either we already have the Privilege granted, or it's	** implied by the effective-uid of root, but we do not allow user authentication now.	** If it fails, it fails, and the Envoy will terminate appropriately.	**<p>	** This use of authorize() is the typical approach to guarding a restricted section of code.	** Do not omit it just because you think it's safe to assume it's running as root.	** Good security means not making assumptions.	*/	public int	perform( String[] args, Authorization auth )	{		// Enforce the security design using authorize().		// Use the root-exec Privilege with the specific command-name.		// It may not be an absolute pathname, since we're ultimately calling		// Runtime.exec(), which knows how to use the PATH environment-variable.		Privilege needed = auth.makeExecPrivilege( args[ 0 ] );		auth.authorize( needed, false );		// Execute args as progArray, no stdin, schlep stdout, schlep stderr.		return( execute( args, null, System.out, System.err ) );	}}