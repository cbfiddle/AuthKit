/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package app.authkit.tools;import java.io.*;import java.util.*;import app.util.FileDialogger;import glguerin.authkit.*;// --- Revision History ---// 23Jul2003 GLG  create// 24Jul2003 GLG  clean up// 25Jul2003 GLG  call failed() and alert()// 06Aug2003 GLG  call detach(true) in 'finally' clause// 07Aug2003 GLG  add code to exclude Mac OS 10.0, for safety reasons// 09Aug2003 GLG  add call to presupposeProperty()/**** AppBundleLockdown is a Tool that locks down an app-bundle.** It takes pathnames as args, or prompts for an app-bundle using a FileDialog** when no args are given.**<p>** This tool refuses to run on Mac OS 10.0.  The version of Java on that version of Mac OS X** won't permit a FileDialog to choose an app-bundle, among other problems.** Mac OS 10.0 also has different Authorization Services rules, which I think are too lax.** In all, it's not a reliable enough platform to be doing this kind of thing on,** so the simplest approach is to identify it and exclude it.**<p>** If no args are given, a FileDialog is presented, but first the user is preauthorize()'d.** The reason for preauthorizing is so users don't get the chance to select an app-bundle** if they can't ultimately carry out the lockdown on it.** There is no other reason for preauthorizing.** Preauthorizing only occurs when no args are given.**<p>** Command-line args, if any, are canonicalized and validated as app-bundles** before being passed to the privileged process.** Canonicalization implies that symlinks in command-line args are followed.** Validation as an app-bundle is limited, though it shouldn't ever reject a** valid app-bundle, as long as it contains a well-formed 'APPL' PkgInfo file.** Without a PkgInfo, rejection is certain.**<p>** Finder-aliases are not followed, unless one is chosen interactively.**<p>** Symlinks found while traversing the app-bundle's contents are not followed, ** under control of the command execution in the Task** app.authkit.tools.tasks.AppBundleLockdownTask.****<h3>System Properties Used</h3>**** Uses the app.authkit.envoy.Tool properties, including "alert".**<dl>**  <dt>"keep.DS_Store" boolean, default false</dt>**  <dd>**    should all '*.DS_Store' files in the app-bundle be kept (T) or deleted (F)?**  </dd>****  <dt>"verbose" boolean, default false</dt>**  <dd>**    should the Envoy process's encoded output be echoed to stdout (T) or discarded (F)?**  </dd>**</dl>****<h3>Exit Status Codes</h3>****<dl type="compact">**  <dt>0</dt>**  <dd>Envoy process exited OK, implying that privileged Task returned successfully.**  </dd>****  <dt>1</dt>**  <dd>IOException for some reason briefly explained on stderr and/or in alert.**  </dd>****  <dt>2</dt>**  <dd>UnauthorizedException for some reason briefly explained on stderr and/or in alert.**  </dd>****  <dt>3</dt>**  <dd>any other Throwable, as explained on stderr and/or in alert..**  </dd>** @author Gregory Guerin**** @see app.authkit.envoy.Tool** @see app.authkit.tools.tasks.AppBundleLockdownTask*/public class AppBundleLockdown  extends app.authkit.envoy.Tool{	/** Static entry point when used as an application or command-line tool. */	public static void 	main( String[] args ) 	{  new AppBundleLockdown().perform( args );  }	/**	** Perform this Tool's actions on the given args.	*/	public void 	perform( String[] args )	{		// Create Authorization and attach it to a new session.		Authorization auth = newAuth();		auth.isAvailable( Privilege.EMPTY );//		explain( "#Auth: " + auth.getClass() );		// Hack for Mac OS 10.1 running JavaApplicationStub.		args = stripPrefixed( args, "-psn_" );		int status = 0;		try		{			// Exclude Mac OS 10.0.  Its Java is too flaky for this program to work.			if ( System.getProperty( "os.name", "" ).startsWith( "Mac OS" ) )			{				if ( System.getProperty( "os.version", "" ).startsWith( "10.0" ) )					throw new IOException( "Can't run under Mac OS 10.0" );			}			// If no args supplied, prompt for a target to operate on, selected with FileDialog.			if ( args.length == 0 )			{				// An interactive FileDialog presupposes an alert will present the results.				presupposeProperty( "alert", "true" );				// Before doing FileDialog, preauthorize the privileged-execution Privilege.				// We'll need it to run Envoy as a privileged process, and there's				// no point in asking for a target-file if user can't authenticate.				auth.preauthorize( auth.makeExecPrivilege( null ) );				args = chooseTarget( "Choose an application to lock down", FileDialogger.LOAD_APP );				if ( args == null )  // cancelled					throw new IOException( "Cancelled" );			}			// Validate each arg as referring to an app-bundle.			// Also convert each arg to its absolute canonical pathname,			// so Envoy's Tasks are not dependent on current directory or other pathname vulnerabilities.			// Canonicalization effectively follows symlinks given as args.			// It has no effect on Finder-aliases given as args.			for ( int i = 0;  i < args.length;  ++i )			{  args [ i ] = mustBeAppBundle( args[ i ] );  }			// Translate my system property into one available to Envoy Tasks under "envoy.*" name.			// This must happen before makeEnvoyCommand() is called.			if ( Boolean.getBoolean( "keep.DS_Store" ) )				System.getProperties().put( "envoy.keep.DS_Store", "true" );			// Build a complete 'java ...' command-line to run as a privileged process.			String[] envoyCmd = makeEnvoyCommand( "bin/java", null,					"app.authkit.envoy.Envoy", "envoy.",					"app.authkit.tools.tasks.AppBundleLockdownTask", args );			// If system property indicates verbose, then waitForEnvoy() writes to stdout,			// otherwise it consumes the data.			OutputStream out = null;			if ( Boolean.getBoolean( "verbose" ) )				out = System.out;			// Start the privileged process, then wait for it to finish.			// Really just wait for EOF on its piped stream, parsing its output.			Process child = auth.execPrivileged( envoyCmd );			status = waitForEnvoy( child.getInputStream(), out );			// Turn Envoy process failures into an IOException.			if ( status != 0 )				throw new IOException( "Envoy process failed: status code " + status );			// Getting here, status is valid, so leave the try/catch/finally construct.		}		catch ( IOException why )		{			// If unusable, summarize why, and depart with failure code.			failed( why, false, "Lockdown Failed" );			depart( 1 );		}		catch ( UnauthorizedException why )		{			// If unauthorized, summarize why, and depart with failure code.			failed( why, false, "Lockdown Failed" );			depart( 2 );		}		catch ( Throwable other )		{			// Other failures will fully explain why, then depart with failure code.			failed( other, true, "Lockdown Failed" );			depart( 3 );		}		finally		{			// Destroys all shared credentials.			auth.detach( true );		}		// Getting here implies success.  Prepare text for possible alert.		String[] success = new String[ args.length + 1 ];		success[ 0 ] = "Locked down these app-bundles:";		System.arraycopy( args, 0, success, 1, args.length );		// May show alert, or do nothing at all if no "alert" property.		alert( "Success", success );		depart( status );	}}