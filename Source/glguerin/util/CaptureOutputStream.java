/*** Copyright 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>*/package glguerin.util;import java.io.*;// --- Revision History ---// 26Jul2003 GLG  create /**** CaptureOutputStream is a FilterOutputStream that captures** and retains the last N bytes written to it, where N is a constructor arg.** A copy of the captured bytes can be returned at any time,** even after close().**<p>** Bytes are NOT captured if the underlying OutputStream throws an** IOException from its write().**** @author Gregory Guerin*/public class CaptureOutputStream  extends FilterOutputStream{	private byte[] captured;	private int put;	private boolean around;	/** Writes to OutputStream, capturing last N bytes written. */	public	CaptureOutputStream( OutputStream out, int N )	{		super( out );  // superclass field name: out		if ( N < 2 )			throw new IllegalArgumentException( "N must be >= 2: " + N );		captured = new byte[ N ];		put = 0;		around = false;	}	/**	** Return a copy of the bytes most recently captured.	** This will  be fewer than N in the constructor if less than N	** bytes have been written.	** This will be none (i.e. a zero-length byte[]) if no	** bytes have been written.	*/	public byte[]	getCaptured()	{		byte[] result;		if ( around )		{			result = new byte[ captured.length ];			int above = captured.length - put;			System.arraycopy( captured, put, result, 0, above );			System.arraycopy( captured, 0, result, above, put );		}		else		{			result = new byte[ put ];			System.arraycopy( captured, 0, result, 0, put );		}		return ( result );	}	/** Write one byte. */	public void	write( int abyte )	  throws IOException	{		// If IOException thrown, then abyte is not captured.		out.write( abyte );		captured[ put++ ] = (byte) abyte;		if ( put >= captured.length )		{  put = 0;  around = true;  }	}	/** Write range of byte-array. */	public void	write( byte[] bytes, int offset, int count )	  throws IOException	{		// If IOException thrown, then data is not captured.		out.write( bytes, offset, count );		// If count would fill or overflow capture-buffer, refill it completely.		if ( count >= captured.length )		{			offset = offset + count - captured.length;			System.arraycopy( bytes, offset, captured, 0, captured.length );			put = 0;  around = true;			return;		}		// Getting here, count is smaller than capture-buffer.		// If 'put' would wrap around before count is exhausted,		// copy only the first section into capture-buffer at 'put',		// adjusting put, offset, and count accordingly.		if ( put + count >= captured.length )		{			// Fill buffer above current 'put', wrap 'put' around to 0.			// Adjust offset and count accordingly.			int span = captured.length - put;			System.arraycopy( bytes, offset, captured, put, span );			put = 0;  around = true;			offset += span;			count -= span;		}		// At this point, any remaining bytes go at 'put' with no possibility of wraparound.		// The count may be zero because it was originally zero,		// or because it became zero during a calculation above.		if ( count > 0 )		{			System.arraycopy( bytes, offset, captured, put, count );			put += count;		}	}}