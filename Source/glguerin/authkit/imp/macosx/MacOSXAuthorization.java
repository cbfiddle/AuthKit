/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit>*/package glguerin.authkit.imp.macosx;import java.util.Date;import java.util.Enumeration;import glguerin.authkit.Authorization;import glguerin.authkit.Privilege;import glguerin.authkit.UnauthorizedCancellation;import glguerin.authkit.UnauthorizedException;import glguerin.util.LibLoader;// --- Revision History ---// 05Nov2002 GLG  create// 18Nov2002 GLG  use dual-String form of Privilege constructor// 18Nov2002 GLG  revise for new execPrivileged() args// 19Nov2002 GLG  improve check() using paramErrors array// 21Nov2002 GLG  cover externalize() changes// 26Nov2002 GLG  add fileRef arg to rootExec() params// 27Nov2002 GLG  add pair() internal-use function// 29Nov2002 GLG  remove pair(), after need for it evaporated// 10Jun2003 GLG  add testable revoke()// 11Jun2003 GLG  cut revoke(), since it doesn't work as needed// 12Jun2003 GLG  add destroy()// 15Jun2003 GLG  add getCapabilities()// 15Jun2003 GLG  refactor authorize() and preauthorize()// 15Jun2003 GLG  refactor to give detach()// 16Jun2003 GLG  add more flags to getCapabilities()// 18Jun2003 GLG  refactor past-granted methods// 19Jun2003 GLG  add HAS_PROCESS_ELEVATED to getCapabilities()// 24Jun2003 GLG  add options arg to native rootExec() and internalizePriv()// 02Jul2003 GLG  edit doc-comments// 06Aug2003 GLG  add cancellation test to check()/**** MacOSXAuthorization is an implementation of Authorization for Mac OS X,** based on the native Authorization Services API.**<p>** The policies and rules for MacOSXAuthorization are declared in the file** <b>/etc/authorization</b> on the local host.  It is an XML file, readable** by members of the admin group, but writable only by root.** The policies and rules are system-wide for the local host.** There are no per-user policies or rules, as far as I know.**<p>** The constraints on the privileged Process are largely a consequence of** the Authorization Services functionality for executing a privileged process.** See the getCapabilities() doc-comment for details.****<h3>IMPLEMENTATION NOTES</h3>**** A single Authorization may be called from multiple Threads.** It must therefore be inherently thread-safe.** All methods that manipulate state or depend on it are implemented thread-safely.** In short, multiple Threads can safely share a single MacOSXAuthorization instance.** Whether your program will deadlock if it shares a MacOSXAuthorization** among Threads is another question entirely, and one only you can answer.**<p>** The authorize(), preauthorize(), and isAvailable() methods are all** synchronized on the MacOSXAuthorization.  In addition to ensuring** the thread-safety of the instance's state, this also ensures that one Thread** which is blocked in interactive authentication will prevent all other calling Threads** from progressing until the user authenticates correctly or the authentication fails.** This makes sense not only from a thread-safety perspective, but from** the security perspective as well.  You don't want multiple password dialogs,** but you also don't want an authentication in-progress to return indeterminate or transitory** results just because it's from another thread.**<p>** All the native functions are static and synchronized.** That is, they are synchronized on the Class object.**<p>** The functions are static because we don't need the instance object in the native code.** All the necessary state is communicated and managed by the opaque session-token.**<p>** The functions are synchronized because I don't know whether the Authorization Services API** is re-entrant for a process.** The Auth Services API will definitely block the calling thread when interacting with the user.** By acquiring the class lock before calling the native code, we ensure that Java threads** will properly block before making any Auth Services API call, preventing re-entrancy issues,** but possibly introducing deadlock issues.** If the blocked calling thread is the AWT event-thread, this may have AWT or Swing repurcussions,** which may in turn affect program responsiveness.**<p>** For obvious security reasons that have nothing to do with Auth Services re-entrancy,** the current thread must be blocked while obtaining interactive authentication.** It's the length of time that the thread could be blocked that poses a potential problem.**<p>** As a rule, don't call anything from the AWT event-thread that may cause user interaction,** and therefore lead to long or indefinite thread blocking.**<p>**<b> REFERENCES:</b>**<dl>**  <dt>**   On security in Mac OS X --**  </dt><dd>**    <a href="http://developer.apple.com/security/">Developer -- Mac OS X Security</a>**    <br>Contains links to sample code, mailing-list, API and reference documentation, etc.**  </dd>****  <dt>**   On the Authorization Services concepts and principles --**  </dt><dd>**    <a href="http://developer.apple.com/documentation/Security/Conceptual/authorization_concepts/index.html">**    Performing Privileged Operations With Authorization Services</a>**    (HTML and PDF available).**  </dd>****  <dt>**   On the Authorization Services C API --**  </dt><dd>**    <a href="http://developer.apple.com/documentation/Security/Reference/authorization_ref/index.html">**    Authorization Services Reference</a>**    (HTML and PDF available).**  </dd>****  <dt>**   On synchronized static native methods --**  </dt><dd>**   JNI Programmers's Guide & Specification: section 8.1.2, p.95**    available**    <a href="http://java.sun.com/docs/books/jni/html/jniTOC.html">as HTML</a>**    or**    <a href="ftp://ftp.javasoft.com/docs/specs/jni.pdf">as PDF</a>.**  </dd>****</dl>**** @author Gregory Guerin*/public final class MacOSXAuthorization  extends Authorization{	/**	** Authorization options, from "Security/Authorization.h".	*/	private static final int		DEFAULT = 0x00,		INTERACT = 0x01,		EXTEND = 0x02,//		PARTIAL = 0x04,	// ## unneeded, since this imp never asks for partial rights		DESTROY = 0x08,		PREAUTH = 0x10;  // ## ineffective.  See getCapabilities() doc-comment.	/**	** A list of result-codes that should throw an IllegalArgumentException.	** Any other result-codes throw an UnauthorizedException.	*/	private static final int[] paramErrors;	static	{		// Perform once-only static initialization for class.		// If the list of illegal-arg errors was much longer, a Hashtable would be worth using.		// As it is, a sequential search is not so bad, even if all items are skipped.		paramErrors = new int[]  { -1, -60001, -60002, -60003, -60004, -60011 };		// Load JNI library holding all native methods for all imp's classes.		LibLoader.getLoader().loadLibrary( "AuthKit" );	}	/**	** Holds an opaque "tokenized" representation of an AuthorizationRef.	** If the value is 0, then no session is active.	** If the value is non-zero, then it's a "session token".	**<p>	** The session token is passed to the native methods, which are the only	** ones that actually know what the token means.	** The token could be a pointer, an index, or an identifier, depending on	** the actual implementation of the JNI functions.	** Whatever the imp, the Java code always represents the session token as an int.	*/	private long mySession;	/** Vanilla constructor. */	public	MacOSXAuthorization()	{		super();		mySession = 0;	}	/**	** This imp has the following notable capabilities and/or constraints:	**<dl>	**  <dt>HAS_PROCESS_COUPLED_STREAMS</dt>	**  <dd>	**   An execPrivileged() child Process has interdependent input and output streams.	**  </dd>	**	**  <dt>HAS_PROCESS_INPUTSTREAM</dt>	**  <dd>	**   An execPrivileged() child Process implements getInputStream().	**  </dd>	**	**  <dt>HAS_PROCESS_OUTPUTSTREAM</dt>	**  <dd>	**   An execPrivileged() child Process implements getOutputStream().	**  </dd>	**	**  <dt>HAS_PROCESS_ELEVATED</dt>	**  <dd>	**   An execPrivileged() child Process runs with an effective user-ID of root (superuser).	**   Its real user-ID is unaffected, as are its real and effective group-ID.	**  </dd>	**	**  <dt>HAS_SYNTHETIC_PREAUTH</dt>	**  <dd>	**   The preauthorize() method is exactly the same as calling	**   authorize() with true for interactionAllowed.	**   Real preauthorization is not provided.	**  </dd>	**	**  <dt>HAS_SESSION_MULTIPROCESS</dt>	**  <dd>	**   Secret identifiers work across process boundaries.	**   This makes them much more valuable as secrets.	**   They are still transitory, however, so are valuable only as long as the session exists.	**  </dd>	**	**</dl>	**<p>	** According to Quinn (the Eskimo!), in the "Read Me About MoreAuthSample"	** documentation for MoreAuthSample v1.0b2:	**<blockquote>		... the preauthorization flag (kAuthorizationFlagPreAuthorize)		does nothing on current versions of Mac OS X [2907852].	**</blockquote>	** This statement coincides with my own experimental results.	** Earlier trials showed that trying to preauthorize	** a rule having timeout=0 simply did not work as Apple's documentation described.	** Whew, I thought it was just me.	**<p>	** The Auth-Services API function that actually executes	** a program as a privileged process is notable for its limitations:	**<ul>	** <li>	** The returned FILE * points to a bi-directional pipe, which inextricably couples stdin and	** stdout of the child process, so you can't close its stdin to signal EOF without also	** closing its stdout and thereby being unable to read results.	** Hence the presence of HAS_PROCESS_COUPLED_STREAMS.	** </li>	** <li>	** The privileged Process's stderr is simply inherited from the parent process,	** so it's typically just going to spew error-text onto the system console, rather	** than let the parent process parse it or decode error-results from it.	** No, that might be too useful.	** Hence the absence of HAS_PROCESS_ERRORSTREAM.	** </li>	** <li>	** There is no way to know or discover the process-ID (pid) of the privileged child Process.	** Who would want to know that?  After all, just because it's a required parameter for	** wait(), or wait4(), or kill(), who'd want to wait for the child or send it signals?  Naah.	** Hence the absence of HAS_PROCESS_WAITFOR, HAS_PROCESS_EXITVALUE,	** and HAS_PROCESS_DESTROY.	** </li>	**</ul>	*/	public int	getCapabilities()	{  return ( HAS_PROCESS_COUPLED_STREAMS				| HAS_PROCESS_INPUTSTREAM				| HAS_PROCESS_OUTPUTSTREAM				| HAS_PROCESS_ELEVATED				| HAS_SYNTHETIC_PREAUTH				| HAS_SESSION_MULTIPROCESS );  }	/**	** Authorize the given Privilege, granting approval to exercise it immediately.	** If the Privilege is granted or was already available, this method returns normally.	** If the Privilege is not granted, an UnauthorizedException is thrown.	**<p>	** Interaction with the user is allowed or forbidden according to 'interactionAllowed'.	** The current thread is blocked while any user-interaction is occurring.	** If interaction is allowed, and the user does not authenticate properly, this method fails.	** If interaction is forbidden, and the privilege is not already available, this method fails.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the requested Privilege is not granted.	** @exception java.lang.IllegalArgumentException	**   thrown when the Privilege is malformed, or some other structural error occurs.	*/	public void	authorize( Privilege toGrant, boolean interactionAllowed )	{		int options = EXTEND;		if ( interactionAllowed )			options |= INTERACT;		check( claim( toGrant, options ) );		addGranted( toGrant );	}	/**	** This method is a synthetic implementation.	** It simply calls authorize(), since the PREAUTH option-flag isn't distinguished	** as of Mac OS X v10.2.*.	** Since this isn't a real preauthorize(), getCapabilities() returns a bit-mask	** value containing HAS_SYNTHETIC_PREAUTH.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the requested Privilege is not granted.	** @exception java.lang.IllegalArgumentException	**   thrown when the Privilege is malformed, or some other structural error occurs.	**	** @see #authorize	** @see #getCapabilities	*/	public void	preauthorize( Privilege toGrant )	{  authorize( toGrant, true );  }	/** Is the given Privilege currently available (authorized, preauthorized, or implied)? */	public boolean	isAvailable( Privilege toCheck )	{		// A call to claim() without any options is effectively "check for authorized".		return ( claim( toCheck, DEFAULT ) == 0 );	}	/**	** Call native method request(), returning result-code.	** First performs lazy creation of a non-zero session token, calling native makeSession()	** and using check() to check for success.  This means an exception may be thrown here.	**<p>	** Acquire this instance's lock for its own thread-safety in assigning a value to mySession.	** Also so in-progress authentications block other threads from indeterminate or	** transitory states.	*/	private synchronized int	claim( Privilege what, int options )	{		// Lazy session creation...		if ( mySession == 0 )		{			long[] ref = new long[ 1 ];			check( makeSession( ref ) );			mySession = ref[ 0 ];		}		return ( request( mySession, options, what.getName(), what.getValue(), what.getFlags() ) );	}	/**	** Check the result-code, throwing an appropriate unchecked exception for failures,	** or returning normally for success.	** An IllegalArgumentException is thrown for bad-parameter failures.	** An UnauthorizedCancellation is thrown if authentication was cancelled.	** An UnauthorizedException is thrown for authentication failures or any other error.	*/	private void	check( int result )	{		if ( result == 0 )			return;		// BUG-FIX:  The internalize() and internalizePriv() functions have been seen to		// return the result-code 0x80010001 if the represented session has been destroyed.		// This result-code value is either completely wrong or is mysteriously undocumented.		// It should be -60010: "The Security Server denied internalization..."		// or perhaps -60002: "The authorization parameter is invalid".		// I'm using -60010 as the replacement, so an UnauthorizedException will be thrown.		if ( result == 0x80010001 )			result = -60010;		// Filter out parameter errors and throw an IllegalArgumentException for 'em.		for ( int i = 0;  i < paramErrors.length;  ++i )		{			if ( result == paramErrors[ i ] )				throw new IllegalArgumentException( "Authorization error: " + result );		}		// Choose which exception to throw, with appropriate message.		if ( result == -60006 )			throw new UnauthorizedCancellation( "Authorization cancelled" );		throw new UnauthorizedException( "Authorization denied: " + result );	}	/**	** Detach this Authorization from any underlying session, acting on shared	** authorizations in the manner given by the boolean.	**<p>	** In this implementation,	** acquire this instance's lock for its own thread-safety in assigning a value to mySession.	*/	public synchronized void	detach( boolean revokeShared )	{		int options = DEFAULT;		if ( revokeShared )			options = DESTROY;		if ( mySession != 0 )		{			// Always clear the past Privileges before anything else happens.			clearGranted();			// Move the instance variable to a local variable, and clear the instance variable.			// Clearing the instance variable now ensures it will be cleared even if check()			// throws an exception.  This approach avoids a 'finally' clause.			long toKill = mySession;			mySession = 0;			if ( false )			{				String hexed = "0x" + Long.toHexString( toKill ).toUpperCase();				System.err.println( "## MacOSXAuth.detach(): " + hexed + ", " + options );			}			check( killSession( toKill, options ) );		}	}	/**	** Return an Enumeration (possibly empty, but never null)	** representing all past Privileges granted by authorize() or preauthorize().	** The Enumeration's nextElement() method returns a Privilege.	**<p>	** This method DOES NOT create a new session if one is not attached.	** This method never throws an UnauthorizedException.	*/	public Enumeration	getPastGrantedPrivileges()	{  return ( keysGranted() );  }	/**	** If the given Privilege was previously granted, return a Date	** representing the timestamp of when that last occurred.	**	** @exception java.lang.IllegalArgumentException	**   thrown if 'when' is an invalid value.	*/	public Date	getPastGrantedDate( Privilege privilege, int when )	{		if ( when < WHEN_EARLIEST  ||  when > WHEN_LATEST )			throw new IllegalArgumentException( "Don't know when: " + when );		return ( whenGranted( privilege, when ) );	}	/**	** Make and return a Privilege representing the ability to execute a program	** with elevated privileges by way of execPrivileged().	**<p>	** The name of the returned Privilege is "system.privilege.admin" (see "AuthorizationTags.h").	** Its value is the UTF-8 encoding of the cmdName.	*/	public Privilege	makeExecPrivilege( String cmdName )	{		// If cmdName can't be encoded to UTF-8, the value will be null,		// so the privilege should not be granted, nor the exec allowed.		// At least that's how I think Auth Services should react.		// It doesn't seem to, though.  Oh well...		return ( new Privilege( "system.privilege.admin", cmdName, 0 ) );	}	/**	** Execute a program as if run by a privileged user, or with temporarily elevated privileges.	** If the execution privilege is denied, an UnauthorizedException is thrown and no program is executed.	** If authorization succeeds, a Privilege is added to the past granted Privileges.	**<p>	** In this implementation, the program is run with an effective user-ID of root.	** The real user-ID, along with the real and effective group-ID's, are unchanged.	**<p>	** The program named in progArray[0] must be accessible to the current unprivileged user-ID.	** That is, the current process must have search-permission on all directories	** leading to the executable, and have execute-permission on the file itself.	** It isn't good enough if root has access, since the privileges are not elevated to root	** until AFTER the executable has been loaded into memory.	**<p>	** The program named in progArray[0] must be an absolute pathname.	** The PATH environment-variable is not used to search for a command,	** as it is for Runtime.exec().	** This is done for security reasons, so an attacker can't forge or taint a PATH that	** would cause an unexpected program to run as root.	**<p>	** If no session is active, one is established first.	** If the necessary Privilege is not already available or preauthorized,	** an interactive dialog will be presented, blocking the current Thread.	** If your program absolutely cannot tolerate blocking the current Thread,	** then call this method on its own Thread,	** or arrange to preauthorize() or authorize() first,	** or qualify the call to this method with a call to isAvailable().	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the necessary Privilege is not available or preauthorized,	**   or the program is inaccessible, malformed, or otherwise unexecutable.	** @exception java.lang.IllegalArgumentException	**   thrown when some malformation or structural error occurs.	*/	public Process	execPrivileged( String[] progArray )	{		// This ensures that mySession is valid.  We don't care what the result is.		claim( Privilege.EMPTY, DEFAULT );		if ( progArray == null  ||  progArray.length == 0 )			throw new IllegalArgumentException( "Null or empty String[]" );		// The native function ultimately calls AuthorizationExecuteWithPrivileges(), which expects		// its args array to hold only the command's parameters, omitting the cmd-name itself.		// This form differs from that used by execve(2) and related BSD-lib functions.		// It also differs from what Runtime.exec(String[]) expects.		// To get to the proper form, we must replicate progArray without its 0'th item.		// And of course, we must take the program-name itself from progArray[0].		// Let the native function deal with any other constraints on the program-name,		// including the fact that it must be an absolute pathname.		String command = progArray[ 0 ];		if ( command == null  ||  command.length() == 0 )			throw new IllegalArgumentException( "Null or empty command" );		String[] args = new String[ progArray.length - 1 ];		System.arraycopy( progArray, 1, args, 0, args.length );		// The pipe's file-descriptors are returned in fdRef: read[0], write[1].		// Although the Auth-Svcs function uses a FILE *, the native method returns filedes's,		// to avoid issues with buffering, deallocating FILE structs, etc.		// Unfortunately, these filedes's can't be represented with java.io.FileDescriptor,		// because the implementation specifics aren't necessarily compatible.		int[] fdRef = new int[ 2 ];		check( rootExec( mySession, DEFAULT, command, args, fdRef ) );		// Getting here, the child process must be started.  Represent it with an AuthProcess .		AuthProcess child = new AuthProcess( command, fdRef[ 0 ], fdRef[ 1 ] );		// Since rootExec() implicitly authorize()'s in order to execute the command,		// we represent it with a past granted Privilege for the specific command.		addGranted( makeExecPrivilege( command ) );		return ( child );	}	/**	** Return the required length of a buffer that can hold the secret session identifier.	**<p>	** This is the size in bytes of	** the AuthorizationExternalForm type defined by the Authorization Services API.	*/	public int	getSecretLength()	{  return ( 32 );  }	/**	** Return a secret session ID underlying this Authorization.	** If no session is active, one <b>IS NOT</b> established first, and a zero-length byte[] is returned.	** Otherwise the secret identifier is put into a new byte[], which is returned.	**<p>	** The returned secret identifier is identical with	** the AuthorizationExternalForm type defined by the Authorization Services API.	** Therefore, it can be sent to any other program that uses Authorization Services,	** and the available credentials and privileges will be shared.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the secret identifier cannot be obtained.	** @exception java.lang.IllegalArgumentException	**   thrown when something really bad or stupid happens.	*/	public synchronized byte[]	getSecretIdentifier()	{		long session = mySession;		if ( session == 0 )			return ( new byte[ 0 ] );		// Same length as returned by getSecretLength().		byte[] secret = new byte[ 32 ];		check( externalize( session, secret ) );		return ( secret );	}	/**	** Attach this Authorization to the underlying session identified by the secret session identifier.	** This Authorization must be newly constructed or recently detach()'ed.	** The underlying session identified by the secretIdentifier	** must still be active (alive), or an UnauthorizedException will be thrown.	**<p>	** The supplied "secret identifier" is identical with	** the AuthorizationExternalForm type defined by the Authorization Services API.	** Therefor, any other program that uses Authorization Services can send those	** bytes to a Java program using a MacOSXAuthorization, and the Java program	** will have access to all the same credentials and privileges.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the session identified by the secret cannot be attached because it has vanished.	** @exception java.lang.IllegalArgumentException	**   thrown when some malformation or structural error occurs.	** @exception java.lang.IllegalStateException	**   thrown when this Authorization already represents an active session.	**   That is, when this Authorization is not newly created or recently detach()'ed.	*/	public synchronized void	attach( byte[] secretIdentifier )	{		if ( secretIdentifier == null  ||  secretIdentifier.length < 32 )			throw new IllegalArgumentException( "Null or insufficient byte[]" );		if ( mySession != 0 )			throw new IllegalStateException( "Session active" );		// In case it's out of sync with session ID.		clearGranted();		long[] ref = new long[ 1 ];		check( internalize( secretIdentifier, ref ) );		mySession = ref[ 0 ];	}	/**	** Attach this Authorization to the same session used by execPrivileged() in	** the parent process.	** That session is only available to child processes executed by execPrivileged(),	** and needs no secret identifier.	** If the current process is not a child by execPrivileged(), then this method fails.	**<p>	** This implementation eventually calls the Authorization Services API function	** AuthorizationCopyPrivilegedReference().	** Therefore, any other program that uses Authorization Services can	** execute a Java program using AuthorizationExecuteWithPrivileges(), and	** the privileged session will be available to the Java program	** after calling this method.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when there is no privileged session to attach to.	** @exception java.lang.IllegalArgumentException	**   thrown when some malformation or structural error occurs.	** @exception java.lang.IllegalStateException	**   thrown when this Authorization already represents an active session.	**   That is, when this Authorization is not newly created or recently detach()'ed.	*/	public synchronized void	attachPrivileged()	{		if ( mySession != 0 )			throw new IllegalStateException( "Session active" );		// In case it's out of sync with session ID.		clearGranted();		long[] ref = new long[ 1 ];		check( internalizePriv( DEFAULT, ref ) );		mySession = ref[ 0 ];	}	// ###  J N I   F U N C T I O N   B I N D I N G S  ###	/**	** Make a new session token.	 * @return  result-code	 */	private static native synchronized int		makeSession( long[] sessionRef );	/**	** Free a session token.	 * @return  result-code	 */	private static native synchronized int		killSession( long session, int options );	/**	** The session is from makeSession() or an internalization.	** The options are the AuthorizationFlags, i.e. the "options" representing actions/cmds.	** The name, value, and flags designate a single Right.	**	 * @return  result-code	 */	private static native synchronized int		request( long session, int options, String name, byte[] value, int flags );	/**	** Execute a process with root privileges.	 * @return  result-code	 */	private static native synchronized int		rootExec( long session, int options, String pathToTool, String[] toolArgs, int[] fdRef );	/**	** The session is from makeSession() or internalized from another session.	**	 * @return  result-code	 */	private static native synchronized int		externalize( long session, byte[] buffer );	/**	** The bytes are the externalized form.	 * @return  result-code	 */	private static native synchronized int		internalize( byte[] buffer, long[] sessionRef );	/**	** Only works in child by rootExec().	 * @return  result-code	 */	private static native synchronized int		internalizePriv( int options, long[] sessionRef );}