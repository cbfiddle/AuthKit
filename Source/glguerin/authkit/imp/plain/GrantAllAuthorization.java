/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package glguerin.authkit.imp.plain;import java.io.IOException;import java.util.Date;import java.util.Enumeration;import glguerin.authkit.*;// --- Revision History ---// 05Nov2002 GLG  create// 07Nov2002 GLG  add internalize() and externalize()// 18Nov2002 GLG  revise for new execPrivileged() args// 19Nov2002 GLG  refactor slightly// 21Nov2002 GLG  cover externalize() changes// 22Nov2002 GLG  make externalize() fill in the buffer// 25Nov2002 GLG  name changes; revise secret-identifier handling// 15Jun2003 GLG  add getCapabilities()// 15Jun2003 GLG  refactor authorize() and preauthorize()// 15Jun2003 GLG  change to detach()// 16Jun2003 GLG  add real getCapabilities()// 18Jun2003 GLG  refactor past-granted methods// 19Jun2003 GLG  add attachment statefulness// 29Jun2003 GLG  add addGranted() in execPrivileged()/**** As its name implies, GrantAllAuthorization is an Authorization that grants all requests.** Every call to authorize() or preauthorize() is always granted, without any user interaction** or authentication of any kind.  Every call to isAvailable() always returns true.** This class is primarily for testing, since it doesn't enforce any restrictions at all.**<p>** The implementation of GrantAllAuthorization uses only plain Java facilities,** so it is entirely platform-neutral.  This has a number of consequences:**<ul>**  <li>There aren't really any underlying sessions.**    As a result, all instances return the same secret identifier bytes,**    have the same public identifier, and are effectively interchangeable.**    The Enumeration of past granted Privileges *IS* instance-specific, though.**  </li>**  <li>The secret identifiers have no meaning across processes.  They aren't even secret,**    since they are always identical.**  </li>**  <li>The execPrivileged() Process doesn't really run with elevated privileges.**    The returned Process is simply a Runtime.exec() child-process.**  </li>**  <li>The attach() and attachPrivileged() methods always work,**    as long as the state is correct (newly constructed or recently detached).**  </li>**</ul>**** @author Gregory Guerin*/public class GrantAllAuthorization  extends Authorization{	private boolean isAttached;	/** Create, unattached but willing. */	public	GrantAllAuthorization()	{  isAttached = false;  }	/**	** Return capabilities indicating a full-featured but unprivileged Process,	** since it isn't actually running with any special privileges.	** The Process does, however, support all the Process methods and facilities.	*/	public int	getCapabilities()	{  return ( HAS_PROCESS_INPUTSTREAM				| HAS_PROCESS_OUTPUTSTREAM				| HAS_PROCESS_ERRORSTREAM				| HAS_PROCESS_EXITVALUE				| HAS_PROCESS_WAITFOR				| HAS_PROCESS_DESTROY );  }	/**	** Always grant the given Privilege.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the requested Privilege is not granted.	** @exception java.lang.IllegalArgumentException	**   thrown when the Privilege is malformed, or some other structural error occurs, i.e. never.	*/	public void	authorize( Privilege toGrant, boolean interactionAllowed )	{  isAttached = true;  addGranted( toGrant );  }	/**	** Always preauthorize the given Privilege.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the requested Privilege is not granted.	** @exception java.lang.IllegalArgumentException	**   thrown when the Privilege is malformed, or some other structural error occurs, i.e. never.	*/	public void	preauthorize( Privilege toGrant )	{  isAttached = true;  addGranted( toGrant );  }	/**	** Is the given Privilege currently available?	**<p>	** This imp always returns true.	*/	public boolean	isAvailable( Privilege toCheck )	{ isAttached = true;   return ( true );  }	/**	** Detach the "session".  That is, change the state to "unattached"	** and clear the past granted Privileges.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the underlying session cannot be properly discarded.	*/	public void	detach( boolean revokeShared )	{  isAttached = false;  clearGranted();  }	/**	** Return an Enumeration (possibly empty, but never null)	** representing all past Privileges granted by authorize() or preauthorize().	*/	public Enumeration	getPastGrantedPrivileges()	{  return ( keysGranted() );  }	/**	** If the given Privilege was previously granted, return a Date	** representing the timestamp of when that last occurred.	**	** @exception java.lang.IllegalArgumentException	**   thrown when some malformation or structural error occurs,	**   or if 'when' is an invalid value.	*/	public Date	getPastGrantedDate( Privilege privilege, int when )	{		if ( when < WHEN_EARLIEST  ||  when > WHEN_LATEST )			throw new IllegalArgumentException( "Illegal when-code: " + when );		return ( whenGranted( privilege, when ) );	}	/**	** Make and return a Privilege representing the right to execute a program as root.	**<p>	** This imp always returns a Privilege with the name "exec.root.granted"	** and a value of the cmdName.  This is essentially meaningless, but is recognizable.	*/	public Privilege	makeExecPrivilege( String cmdName )	{  return ( new Privilege( "exec.root.granted", cmdName, 0 ) );  }	/**	** Execute a program as root (run under root privileges).	** If the privilege is denied, an UnauthorizedException is thrown and no program is executed.	** If authorization succeeds, a Privilege is added to the past granted Privileges.	**<p>	** This imp just calls Runtime.exec(), turning any IOException into an IllegalArgumentException.	**<p>	** The returned Process is not actually running with root privileges, unless the	** current process (i.e. the current program) is also running with root privileges,	** or it happens to be a setuid-root program.  Since plain Java has no means to	** identify either situation, the getCapabilities() value omits HAS_PROCESS_ELEVATED. 	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the necessary Privilege is not granted or preauthorized,	**   or when the program is inaccessible or malformed.	** @exception java.lang.IllegalArgumentException	**   thrown when some malformation or structural error occurs.	*/	public Process	execPrivileged( String[] progArray )	{		isAttached = true;		try		{			// If it succeeds, add a granted Privilege representing it.			Process child = Runtime.getRuntime().exec( progArray );			addGranted( makeExecPrivilege( progArray[ 0 ] ) );			return ( child );		}		catch ( IOException why )		{  throw new IllegalArgumentException( "Execution failed: " + progArray[ 0 ] );  }	}	/**	** Return the length of a buffer that can hold the secret session identifier.	**<p>	** This imp's buffer-length differs from DenyAllAuthorization or MacOSXAuthorization.	*/	public int	getSecretLength()	{  return ( 21 );  }  // half of 42, so only half the meaning of life, the universe, and everything	/**	** Return a secret externalized session ID underlying this Authorization,	** but only when it's in the "attached" state.	**<p>	** This imp fills a byte[] with a fixed pattern.	** The pattern is always: <tt>array[n] = (byte) ~n;</tt>	** Needless to say, this isn't really a secret identifier.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the session identifier cannot be externalized, i.e. never.	*/	public byte[]	getSecretIdentifier()	{		if ( isAttached )		{			byte[] secret = new byte[ getSecretLength() ];			for ( int i = 0;  i < secret.length;  ++i )			{  secret[ i ] = (byte) ~i;  }			return ( secret );		}		else			return ( new byte[ 0 ] );	}	/**	** Attach this Authorization to the session identified by the given secret.	** This Authorization must be newly constructed, or have recently been detach()'ed.	**<p>	** This imp accepts any byte[]'s contents, as long as it has sufficient length.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when the session identifier cannot be internalized, i.e. never.	** @exception java.lang.IllegalArgumentException	**   thrown when some malformation or structural error occurs.	** @exception java.lang.IllegalStateException	**   thrown when this Authorization already represents an active session.	**   That is, when this Authorization is not newly created or recently detach()'ed.	*/	public void	attach( byte[] secretIdentifier )	{		if ( secretIdentifier == null  ||  secretIdentifier.length < getSecretLength() )			throw new IllegalArgumentException();		if ( isAttached )			throw new IllegalStateException( "Session active" );	}	/**	** Does nothing, since this class fakes the entire "execute privileged" thing,	** and never throws an UnauthorizedException for anything.	** This Authorization must be newly constructed, or have recently been detach()'ed.	**	** @exception glguerin.authkit.UnauthorizedException	**   thrown when there is no privileged session to reconnect to, i.e. never.	** @exception java.lang.IllegalStateException	**   thrown when this Authorization already represents an active session.	**   That is, when this Authorization is not newly created or recently detach()'ed.	*/	public void	attachPrivileged()	{		if ( isAttached )			throw new IllegalStateException( "Session active" );	}}