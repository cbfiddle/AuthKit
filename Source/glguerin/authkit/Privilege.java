/*** Copyright 2002-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the Authorization Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/index.html#authkit> */package glguerin.authkit;import java.io.UnsupportedEncodingException;// --- Revision History ---// 04Nov2002 GLG  create// 06Nov2002 GLG  change the value to a byte[], essentially a blob// 09Nov2002 GLG  add dual-String constructor and underlying support// 09Jun2003 GLG  rework with byte[]-copying behavior// 09Jun2003 GLG  refactor constructors// 11Jun2003 GLG  rework internals// 14Jun2003 GLG  add public static EMPTY Privilege/**** A Privilege encapsulates a privilege-name with an optional value-Object and flags.** It represents a privilege to be authorized or otherwise used by an Authorization.**<p>** The meaning (semantics or utility) of a Privilege's name, value, and flags** are always platform-dependent and implementation-dependent.** There may also be application-specific names, values, and flags.** A Privilege name, in particular, usually represents the name of a privilege** or set of privileges defined or described in some security-policy database.** The form, location, and access mechanisms of that database** are irrelevant to the public API of the Privilege or Authorization classes.**<p>** Whether a Privilege needs a value-Object or not depends on the privilege being requested.** It also depends on the Authorization imp, since different imps may do things differently.**<p>** Regardless of the concrete Authorization imp,** a Privilege is immutable once created, for the obvious security reasons.** To maintain this premise, a byte[] value-Object is copied and kept,** rather than keeping the original byte[].  Other types of value-Object have** their toString() representation transformed into a byte[], which is then kept.**<p>** A Privilege's value, if any, is always ultimately represented as a byte[].** All types passed to the constructor, other than byte[], are first represented as a String** by calling the toString() method, then that String is represented as a byte[]** by encoding to UTF-8.** Object types that do not return meaningful results from toString() cannot be** used directly as value-Objects.  All instances of String simply return themselves** from toString(), so Strings are directly usable as value-Objects.**<p>** At this time, few privileges need a value-Object at all.** The main exception to this (at least on Mac OS X) is the privilege to run a program as root** using Authorization.execPrivileged().  To create such a Privilege, you** should always use Authorization.makeExecPrivilege(), rather than** assembling one yourself.  The makeExecPrivilege() method will always create** a Privilege with the appropriate name and value for the implementation.**<p>** Currently, a Privilege's flags are not used by any Authorization implementation.** You should not use them for your own purposes, either.  Doing so could conflict with any** future use by a concrete Authorization imp.**<p>** This class is final for security reasons.** Changing this may have security consequences.**** @author Gregory Guerin**** @see Authorization*/public final class Privilege{	/**	** Public constant Privilege, usable as a dummy or placeholder.	** Its name is the empty String "", and its value is an empty byte[].	*/	public static final Privilege EMPTY;	/** Proxy array when value-Object is null. */	private static final byte[] NOVALUE;	static	{		// The order of static initialization is crucial, so enforce it in an obvious way.		NOVALUE = new byte[ 0 ];		EMPTY = new Privilege( "" );	}	/** Holds the non-null name. */	private final String name;	/** Holds the non-null value associated with the name. */	private final byte[] value;	/** Holds the flags, which serve no purpose yet. */	private final int flags;	/** Holds toString() return-value, calculated only once (in constructor). */	private final String asStr;	/** Construct with given name, a null value, and zero flags. */	public	Privilege( String name )	{  this( name, null, 0 );  }	/**	** Construct with given name, value, and flags.	** The name must not be null.	** The flags should normally be zero, since they are all reserved for future use.	** The value may be null, a byte[], or an instance of some other type.	** Every type other than byte[] must implement a meaningful toString() method,	** which will eventually be turned into a byte[].	**<p>	** If the given value is null, an empty byte[] is assigned to the 'value' instance variable.	** If the given value is a byte[], a replica of it is assigned to the 'value' instance variable.	** If the given value is any other type, its toString() method is called, that String is	** encoded as UTF8 bytes, and that byte[] is assigned to the 'value' instance variable.	** Therefore, any non-null non-byte[] value-Object must return something sensible	** from its toString() method.	**<p>	** Whatever is assigned to the internal instance variable, a replica of it will be	** returned by getValue().	**<p>	** The flags are not currently used by any Authorization implementation,	** and are available for future expansion.  Since all flags are reserved for future use,	** you should normally pass 0 as the flags value.	*/	public	Privilege( String name, Object value, int flags )	{		if ( name == null )			throw new NullPointerException( "Name can't be null" );		// If not assigned anything else, then bytes remains NOVALUE.		byte[] bytes = NOVALUE;		// Build this as we go along, assigning it to asStr at end.		StringBuffer buf = new StringBuffer( name ).append( ":" );		// Decide how to process value-Object...		if ( value == null )		{			// The value is null, so bytes remains as NOVALUE.			// Nothing is appended to buf.		}		else if ( value instanceof byte[] )		{			// The value is a byte[], so make shallow copy with clone().  All arrays provide clone().			bytes = (byte[]) ((byte[])value).clone();			buf.append( "byte[" ).append( bytes.length ).append( "]" );		}		else		{			// The value is some other type, so keep its toString() encoded as UTF8.			try			{  				String str = value.toString();				bytes = str.getBytes( "UTF8" ); 				buf.append( str );			}			catch ( UnsupportedEncodingException why )			{				bytes = NOVALUE;  				buf.append( "Unencodeable " ).append( value.getClass().getName() );			}		}		// Assign to final instance fields...		this.name = name;		this.value = bytes;		this.flags = flags;		this.asStr = buf.append( ":" ).append( flags ).toString();	}	/** Return the non-null name. */	public String	getName()	{  return ( name );  }	/** Return a non-null replica of the value byte[]. */	public byte[]	getValue()	{  return ( (byte[]) this.value.clone() );  }	/** Return the flags. */	public int	getFlags()	{  return ( flags );  }	/** Return a String holding the name, a value-descriptive String, and flags, separated by :'s. */	public String	toString()	{  return ( asStr );  }	/** Return an int that depends on name, value, and flags. */	public int	hashCode()	{		// Because asStr depends on name, value, and flags,		// use asStr's hash as stand-in for hash of value's contents.		return ( asStr.hashCode() );	}	/**	** Return a boolean that depends on the match of name, value, and flags.	** This imp returns true only if other is a Privilege with 	** the same name via String.equals(),	** the same flags via 'int' comparison,	** and the same byte-for-byte value via byte[] element comparison.	** The internal 'asStr' String IS NOT directly involved in the overall test.	**<p>	** Since byte-by-byte comparison is used, two byte-arrays that have the same	** length and contents are considered equal.  This is necessary since the Privilege	** constructors make copies of any byte[] arg supplied.  	** Thus, using byte[].equals(), which tests reference comparison, would not work.	*/	public boolean	equals( Object other)	{		if ( this == other )			return ( true );		if ( other instanceof Privilege )		{			Privilege that = (Privilege) other;			if ( this.name.equals( that.name )  &&  this.flags == that.flags					&&  this.value.length == that.value.length )			{				// Use internal 'value' arrays directly, not getValue() replicas, to avoid copying.				byte[] thisValue = this.value;				byte[] thatValue = that.value;				for ( int i = 0, len = thisValue.length;  i < len;  ++i )				{					if ( thisValue[ i ] != thatValue[ i ] )						return ( false );				}				// Getting here, all bytes matched, so return true.				return ( true );			}		}		return ( false );	}}